<!DOCTYPE html>

<html>
<head>
  <title>`sorting_algorithms.c` &ndash; Utilitários para _arrays_ de `double`</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script src="http://softwaremaniacs.org/media/soft/highlight/highlight.pack.js"></script>
  <script>
    hljs.tabReplace = '        ';
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="array_of_routines.c.html">
                array_of_routines.c
              </a>
            
              
              <a class="source" href="array_utils.h.html">
                array_utils.h
              </a>
            
              
              <a class="source" href="print.c.html">
                print.c
              </a>
            
              
              <a class="source" href="arrays_and_pointers.c.html">
                arrays_and_pointers.c
              </a>
            
              
              <a class="source" href="arrays_basics.c.html">
                arrays_basics.c
              </a>
            
              
              <a class="source" href="command_line.c.html">
                command_line.c
              </a>
            
              
              <a class="source" href="fibonacci.c.html">
                fibonacci.c
              </a>
            
              
              <a class="source" href="hello_world.c.html">
                hello_world.c
              </a>
            
              
              <a class="source" href="hello_world_correct.c.html">
                hello_world_correct.c
              </a>
            
              
              <a class="source" href="linked_list.c.html">
                linked_list.c
              </a>
            
              
              <a class="source" href="malloc_stuff.c.html">
                malloc_stuff.c
              </a>
            
              
              <a class="source" href="nans_and_other_oddities.c.html">
                nans_and_other_oddities.c
              </a>
            
              
              <a class="source" href="rationals_with_structs.c.html">
                rationals_with_structs.c
              </a>
            
              
              <a class="source" href="routine_pointers.c.html">
                routine_pointers.c
              </a>
            
              
              <a class="source" href="experiments.c.html">
                experiments.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.c.html">
                naive_sequence_of_longs.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.h.html">
                naive_sequence_of_longs.h
              </a>
            
              
              <a class="source" href="sequence_of_longs.c.html">
                sequence_of_longs.c
              </a>
            
              
              <a class="source" href="sequence_of_longs.h.html">
                sequence_of_longs.h
              </a>
            
              
              <a class="source" href="tests.c.html">
                tests.c
              </a>
            
              
              <a class="source" href="sizeof_and_arrays.c.html">
                sizeof_and_arrays.c
              </a>
            
              
              <a class="source" href="array_of_doubles.c.html">
                array_of_doubles.c
              </a>
            
              
              <a class="source" href="array_of_doubles.h.html">
                array_of_doubles.h
              </a>
            
              
              <a class="source" href="perform_experiments.c.html">
                perform_experiments.c
              </a>
            
              
              <a class="source" href="sorting_algorithms.c.html">
                sorting_algorithms.c
              </a>
            
              
              <a class="source" href="sorting_algorithms.h.html">
                sorting_algorithms.h
              </a>
            
              
              <a class="source" href="string_io.c.html">
                string_io.c
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1><code>sorting_algorithms.c</code> &ndash; Utilitários para <em>arrays</em> de <code>double</code></h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Este é o ficheiro de implementação correspondente ao ficheiro de
cabeçalho ou interface <a href="sorting_algorithms.h.html"><code>sorting_algorithms.h</code></a>. Ambos
correspondem ao módulo físico <code>sorting_algorithms</code>, cujo objectivo é fornecer
um conjunto de ferramentas para lidar com a ordenação de <em>arrays</em> de
<code>double</code>.</p>
<p>Note que optámos por <em>não</em> incluir comentários de documentação
<a href="http://doxygen.org/">Doxygen</a> em nenhum dos módulos deste programa.</p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2>Inclusões</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h3>Inclusão do próprio ficheiro de interface</h3>
<p>Começamos por incluir o próprio ficheiro de interface. Isso ajuda-nos a
garantir a coerência entre os dois ficheiros, pois desta forma o compilador
poderá gerar erros quando detectar incoerências.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include "sorting_algorithms.h"</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3>Inclusão de outros ficheiros de interface</h3>
<p>Incluímos os vários ficheiro de interface necessários:</p>
<ul>
<li><p><code>stdlib.h</code> &ndash; Para podermos usar o valor especial <code>NULL</code> dos ponteiros
e para podemos usar as rotinas <code>malloc()</code> e <code>free()</code>.</p>
</li>
<li><p><code>assert.h</code> &ndash; Para podermos usar a macro <code>assert()</code>.</p>
</li>
<li><p><code>array_of_doubles.h</code> &ndash; Para podermos usar as rotinas que
desenvolvemos para lidar com <em>arrays</em> de <code>double</code>.</p>
</li>
</ul>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;assert.h&gt;</span>

<span class="preprocessor">#include "array_of_doubles.h"</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2>Definição de constantes globais</h2>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Definimos a constante global que contém a informação acerca de cada
algoritmo, incluindo o respectivo nome e os ponteiros para as rotinas que o
implementam, quer sem, quer com contagem de operações elementares.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">const</span> <span class="keyword">struct</span> sorting_algorithm sorting_algorithms[] = {
	{
		.name = <span class="string">"bubble sort"</span>,
		.sort = bubble_sort,
		.sort_and_count = bubble_sort_and_count
	},
	{
		.name = <span class="string">"selection sort"</span>,
		.sort = selection_sort,
		.sort_and_count = selection_sort_and_count
	},
	{
		.name = <span class="string">"insertion sort"</span>,
		.sort = insertion_sort,
		.sort_and_count = insertion_sort_and_count
	},
	{
		.name = <span class="string">"Shell sort"</span>,
		.sort = shell_sort,
		.sort_and_count = shell_sort_and_count
	},
	{
		.name = <span class="string">"quicksort"</span>,
		.sort = quicksort,
		.sort_and_count = quicksort_and_count
	},
	{
		.name = <span class="string">"merge sort"</span>,
		.sort = merge_sort,
		.sort_and_count = merge_sort_and_count
	},
};

</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Definimos a constante contendo o número de algoritmos considerado, i.e.,
contidos no <em>array</em> anterior.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">const</span> <span class="keyword">int</span> number_of_sorting_algorithms =
	<span class="keyword">sizeof</span>(sorting_algorithms) / <span class="keyword">sizeof</span>(sorting_algorithms[<span class="number">0</span>]);

</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h2>Definição de rotinas auxiliares genéricas</h2>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Começamos por definir rotinas que, sendo auxiliares, não têm ligação externa,
ou seja, são definidas usando o qualificador <code>static</code>. Mais abaixo definimos
outras rotinas auxiliares específicas de determinadas implementações de
rotinas de ordenação.</p>

            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Troca os valores dos itens com índices <code>i</code> e <code>j</code> do <em>array</em> <code>items</code> com
comprimento <code>length</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">static</span> <span class="keyword">void</span> swap(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
		<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j)
{
	assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; length);
	assert(<span class="number">0</span> &lt;= j &amp;&amp; j &lt; length);
	assert(items != NULL);

	<span class="keyword">const</span> <span class="keyword">double</span> original_item_i = items[i];
	items[i] = items[j];
	items[j] = original_item_i;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Troca os valores dos itens com índices <code>i</code> e <code>j</code> do <em>array</em> <code>items</code> com
comprimento <code>length</code> registando o número de operações elementares realizadas.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">static</span> <span class="keyword">void</span> swap_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j,
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; length);
	assert(<span class="number">0</span> &lt;= j &amp;&amp; j &lt; length);
	assert(items != NULL);

	<span class="keyword">const</span> <span class="keyword">double</span> original_item_i = items[i];
	items[i] = items[j];
	items[j] = original_item_i;

	counts-&gt;swaps++;
	counts-&gt;copies += <span class="number">3</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h2>Definição das rotinas de ordenação</h2>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h3>Ordenação por bolha ou <em>bubble sort</em></h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> bubble_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p><em>Arrays</em> vazios ou com apenas um item estão sempre ordenados, pelo
que podemos terminar a execução da rotina.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>A variável <code>unsorted</code> guarda o número de itens que ainda não se sabe
se estão ordenados e na sua posição definitiva. Inicialmente tem como
valor o comprimento do <em>array</em>, pois ainda não se procedeu a qualquer
troca. Após cada iteração do ciclo interior, o maior dos itens que
ainda não se sabe se estão ordenados «flutua» até à sua posição
definitiva, pelo que o valor da variável <code>unsorted</code> é decrementado.
Conceptualmente, o <em>array</em> está dividido em dois segmentos. Os itens
que ainda não se sabe se estão ordenados concentram-se num segmento
com <code>unsorted</code> itens que se encontra no início do <em>array</em>. Os itens
que se sabe estarem ordenados concentram-se num segmento com <code>length</code>
- <code>unsorted</code> itens que se encontra no final do <em>array</em>. O ciclo
principal pára quando só sobra um item que ainda não se sabe se está
ordenado e na posição definitiva, justamente porque, sendo o único
nessas circunstâncias, terá de estar já na sua posição definitiva!</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span> (<span class="keyword">int</span> unsorted = length; unsorted != <span class="number">1</span>; unsorted--)
</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>O ciclo interior não precisa de abarcar senão os itens que
ainda não se sabe se estão ordenados.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != unsorted - <span class="number">1</span>; i++)
</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Sempre que se encontra um par de itens fora de ordem,
troca-se os seus valores, o que leva os itens maiores
a «flutuarem» até encontrarem uma «bolha» maior.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>			<span class="keyword">if</span> (items[i] &gt; items[i + <span class="number">1</span>])
				swap(length, items, i, i + <span class="number">1</span>);

</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Retornamos devolvendo <code>false</code>, i.e., assinalando o sucesso da
ordenação.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <h3>Ordenação por bolha ou <em>bubble sort</em> (com contagem de operações)</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> bubble_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

	<span class="keyword">for</span> (<span class="keyword">int</span> unsorted = length; unsorted != <span class="number">1</span>; unsorted--)
		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != unsorted - <span class="number">1</span>; i++) {
			counts-&gt;comparisons++;
			<span class="keyword">if</span> (items[i] &gt; items[i + <span class="number">1</span>])
				swap_and_count(length, items, i, i + <span class="number">1</span>, counts);
		}

	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h3>Ordenação por selecção ou <em>selection sort</em></h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> selection_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><em>Arrays</em> vazios ou com apenas um item estão sempre ordenados, pelo
que podemos terminar a execução da rotina.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>A variável <code>sorted</code> guarda o número de itens que já se sabe estarem
ordenados e na sua posição definitiva. Inicialmente tem 0 como valor,
pois ainda não se procedeu a qualquer troca. Após cada iteração do
ciclo interior, o menor dos itens que ainda não se sabe se estão
ordenados e na sua posição definitiva é trocado com o item mais à
esquerda dos itens que não se sabe se estão ordenados e na sua
posição definitiva, ficando por isso na sua posição definitiva, pelo
que o valor da variável <code>sorted</code> é incrementado. Conceptualmente, o
<em>array</em> está dividido em dois segmentos. Os itens que se sabe estarem
ordenados e na posição definitiva concentram-se num segmento com
<code>sorted</code> itens que se encontra no início do <em>array</em>. Os itens que
ainda não se sabe se estão ordenados e na posição definitiva
concentram-se num segmento com <code>length</code> - <code>sorted</code> itens que se
encontra no fim do <em>array</em>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span> (<span class="keyword">int</span> sorted = <span class="number">0</span>; sorted != length - <span class="number">1</span>; sorted++) {
</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>O ciclo interior procura o índice do menor dos itens que
ainda não se sabe se estão ordenados e na posição definitiva.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">int</span> i_of_smallest = sorted;
		<span class="keyword">for</span> (<span class="keyword">int</span> i = sorted + <span class="number">1</span>; i != length; i++)
			<span class="keyword">if</span> (items[i] &lt; items[i_of_smallest])
				i_of_smallest = i;
</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>A troca do valor do menor item encontrado e do primeiro dos
itens que ainda não se sabe se estão ordenados e na posição
definitiva só se realiza <em>se não se tratar do mesmo item</em>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">if</span> (i_of_smallest != sorted)
			swap(length, items, sorted, i_of_smallest);
	}

</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Retornamos devolvendo <code>false</code>, i.e., assinalando o sucesso da
ordenação.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h3>Ordenação por selecção ou <em>selection sort</em> (com contagem de operações)</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> selection_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

	<span class="keyword">for</span> (<span class="keyword">int</span> sorted = <span class="number">0</span>;
		sorted != length - <span class="number">1</span>;
		sorted++) {
		<span class="keyword">int</span> i_of_smallest = sorted;
		<span class="keyword">for</span> (<span class="keyword">int</span> i = sorted + <span class="number">1</span>; i != length; i++) {
			counts-&gt;comparisons++;
			<span class="keyword">if</span> (items[i] &lt; items[i_of_smallest])
				i_of_smallest = i;
		}
		<span class="keyword">if</span> (i_of_smallest != sorted)
			swap_and_count(length, items,
					sorted, i_of_smallest, counts);
	}

	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h3>Ordenação por inserção ou <em>insertion sort</em></h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> insertion_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><em>Arrays</em> vazios ou com apenas um item estão sempre ordenados, pelo
que podemos terminar a execução da rotina.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>A variável <code>sorted</code> guarda o número de itens que já se sabe estarem
ordenados embora não necessariamente na sua posição definitiva.
Inicialmente tem 1 como valor, pois, apesar de ainda não se ter
procedido a qualquer alteração no <em>array</em>, o primeiro item do <em>array</em>
está ordenado em relação a sim mesmo, embora possa não estar na sua
posição definitiva. Após cada iteração do ciclo interior, o mais à
esquerda dos itens que ainda não se sabe se estão ordenados é
inserido na posição correcta entre os itens que já estão ordenados,
pelo que o valor da variável <code>sorted</code> é incrementado.
Conceptualmente, o <em>array</em> está dividido em dois segmentos. Os itens
que se sabe estarem ordenados mas não necessariamente na sua posição
definitiva concentram-se num segmento com <code>sorted</code> itens que se
encontra no início do <em>array</em>. Os itens que ainda não se sabe se
estão ordenados concentram-se num segmento com <code>length</code> - <code>sorted</code>
itens que se encontra no fim do <em>array</em>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span> (<span class="keyword">int</span> sorted = <span class="number">1</span>; sorted != length; sorted++) {
</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Guardamos o valor do mais à esquerda dos itens que se ainda
não se sabe se já estão ordenados.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">const</span> <span class="keyword">double</span> item_to_insert = items[sorted];
</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Percorrem-se os itens já ordenados à procura do local onde o
valor que se guardou deve ser inserido, deslocando-se os
itens para a direita no <em>array</em> à medida que a procura
decorre.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">int</span> i = sorted;
		<span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; item_to_insert &lt; items[i - <span class="number">1</span>]) {
			items[i] = items[i - <span class="number">1</span>];
			i--;
		}
</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Insere-se o valor guardado na sua posição definitiva, mas
apenas se esta for diferente da sua posição original.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">if</span> (i != sorted)
			items[i] = item_to_insert;
	}

</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Retornamos devolvendo <code>false</code>, i.e., assinalando o sucesso da
ordenação.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h3>Ordenação por inserção ou <em>insertion sort</em> (com contagem de operações)</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> insertion_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

	<span class="keyword">for</span> (<span class="keyword">int</span> sorted = <span class="number">1</span>; sorted != length; sorted++) {
		counts-&gt;copies++;
		<span class="keyword">const</span> <span class="keyword">double</span> item_to_insert = items[sorted];
		<span class="keyword">int</span> i = sorted;
		<span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; item_to_insert &lt; items[i - <span class="number">1</span>]) {
			counts-&gt;comparisons++;
			counts-&gt;copies++;
			items[i] = items[i - <span class="number">1</span>];
			i--;
		}
		<span class="keyword">if</span> (i != <span class="number">0</span>)
			counts-&gt;comparisons++;
		<span class="keyword">if</span> (i != sorted) {
			counts-&gt;copies++;
			items[i] = item_to_insert;
		}
	}

	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h3>Ordenação de Shell ou <em>Shell sort</em></h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> shell_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p><em>Arrays</em> vazios ou com apenas um item estão sempre ordenados, pelo
que podemos terminar a execução da rotina.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Os incrementos decrescentes a usar pertencem à sucessão 1, 4, 13, 40,
121, etc. Este ciclo procura o valor inicial desses incrementos. Ver
Algorithms, de Robert Sedgewick e Kevin Wayne (4.ª edição), pág. 259.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">int</span> step = <span class="number">1</span>;
	<span class="keyword">while</span> (step &lt; length / <span class="number">3</span>)
		step = <span class="number">3</span> * step + <span class="number">1</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Percorremos cada incremento da sucessão até ao incremento 1.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">while</span> (step &gt;= <span class="number">1</span>) {
</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Executa-se o algoritmo de ordenação por inserção a sub-
<em>arrays</em> entremeados obtidos percorrendo o <em>array</em> em saltos
dados pelo incremento.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">for</span> (<span class="keyword">int</span> i = step; i != length; i++) {
			<span class="keyword">const</span> <span class="keyword">double</span> item_to_insert = items[i];
			<span class="keyword">int</span> j = i;
			<span class="keyword">while</span> (j &gt;= step &amp;&amp; item_to_insert &lt; items[j - step]) {
				items[j] = items[j - step];
				j -= step;
			}
			<span class="keyword">if</span> (j != i)
				items[j] = item_to_insert;
		}
		step /= <span class="number">3</span>;
	}

</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Retornamos devolvendo <code>false</code>, i.e., assinalando o sucesso da
ordenação.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h3>Ordenação de Shell ou <em>Shell sort</em> (com contagem de operações)</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> shell_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

	<span class="keyword">int</span> step = <span class="number">1</span>;
	<span class="keyword">while</span> (step &lt; length / <span class="number">3</span>)
		step = <span class="number">3</span> * step + <span class="number">1</span>;

	<span class="keyword">while</span> (step &gt;= <span class="number">1</span>) {
		<span class="keyword">for</span> (<span class="keyword">int</span> i = step; i != length; i++) {
			counts-&gt;copies++;
			<span class="keyword">const</span> <span class="keyword">double</span> item_to_insert = items[i];
			<span class="keyword">int</span> j = i;
			<span class="keyword">while</span> (j &gt;= step &amp;&amp; item_to_insert &lt; items[j - step]) {
				counts-&gt;comparisons++;
				counts-&gt;copies++;
				items[j] = items[j - step];
				j -= step;
			}
			<span class="keyword">if</span> (j &gt;= step)
				counts-&gt;comparisons++;
			<span class="keyword">if</span> (j != i) {
				counts-&gt;copies++;
				items[j] = item_to_insert;
			}
		}
		step /= <span class="number">3</span>;
	}

	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <h3>Ordenação rápida ou <em>quicksort</em></h3>
<p>A ordenação rápida é implementada recorrendo a um procedimento recursivo de
ordenação de um segmento de um <em>array</em> e a uma rotina que invoca o
procedimento especificando o <em>array</em> completo como segmento a ordenar.</p>

            </div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <h4>Procedimento recursivo auxiliar de ordenação rápida</h4>
<p>Procedimento auxiliar que implementa o algoritmo de ordenação rápida sobre o
segmento do <em>array</em> <code>items</code> (cujo comprimento é <code>length</code>) com início no
índice <code>first</code> e fim no índice <code>last</code>. Este procedimento é recursivo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">static</span> <span class="keyword">void</span> quicksort_segment(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">const</span> <span class="keyword">int</span> first, <span class="keyword">const</span> <span class="keyword">int</span> last)
{
</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h5>Verificação das pré-condições</h5>

            </div>
            
            <div class="content"><div class="highlight"><pre>	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(<span class="number">0</span> &lt;= first);
	assert(last &lt; length);

</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <h5>Verificação dos casos especiais</h5>
<p>Se o segmento tem um número de itens inferior a dois, não é
necessário fazer nada: está ordenado por natureza.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (first &gt;= last)
		<span class="keyword">return</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h5>Particionamento do segmento</h5>
<p>Seleccionamos um <em>pivot</em> e particionamos o segmento de modo a colocar
o <em>pivot</em> no seu lugar definitivo, com todos os itens do segmento à
sua esquerda com valor inferior ou igual ao do <em>pivot</em> e todos os
itens do segmento à sua direita com valor superior ou igual. O
segmento fica, assim, particionado em três partes: (a) sub-segmento
esquerdo, por ordenar, (b) <em>pivot</em> e (c) sub-segmento direito. Depois
deste particionamento, a ordenação total consegue-se ordenando de
forma independente os sub-segmentos esquerdo e direito, usando
exactamente o mesmo algoritmo.</p>

            </div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>O <em>pivot</em> será o primeiro item do segmento. Para simplificar o ciclo
em <code>i</code> do particionamento, em que se procura um item maior ou igual
ao <em>pivot</em> a partir da esquerda, convém garantir que o último item do
segmento não seja inferior ao <em>pivot</em>, pois evita-se ter de verificar
se o valor de <code>i</code> ultrapassa o valor de <code>last</code>. Para o garantir,
compara-se os dois itens extremos do segmento, trocando o seu valor
de modo a garantir que o primeiro é menor ou igual ao último. Dessa
forma, o <em>pivot</em> funcionará como uma <em>sentinela</em> para o ciclo em <code>j</code>
e o último item do segmento funcionará como uma <em>sentinela</em> para o
ciclo em <code>i</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (items[first] &gt; items[last])
		swap(length, items, first, last);
	<span class="keyword">const</span> <span class="keyword">double</span> pivot = items[first];

</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Inicializamos a variável <code>i</code>, que percorrerá o segmento a partir da
esquerda, «saltando» sobre o <em>pivot</em>. Note que a primeira operação
realizada no ciclo em <code>i</code> é uma incrementação, pelo que se salta de
facto o <em>pivot</em>, apesar de se inicializar <code>i</code> com <code>first</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">int</span> i = first;
</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Inicializamos a variável <code>j</code>, que percorrerá o segmento a partir da
direita. Note que a primeira operação realizada no ciclo em <code>j</code> é uma
decrementação, pelo que é necessário inicializar <code>j</code> com <code>last</code> + 1,
e não simplesmente com <code>last</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">int</span> j = last + <span class="number">1</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>O ciclo principal do particionamento serve para ir procurando pares
de itens a trocar, um a partir da esquerda, outro a partir da
direita. O passo do ciclo tem de ser executado pelo menos uma vez,
pelo que é apropriado usar um ciclo <code>do while</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">do</span> {
</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Procura-se o primeiro candidato à troca a partir da esquerda.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">do</span>
			i++;
		<span class="keyword">while</span>(items[i] &lt; pivot);

</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Procura-se o primeiro candidato à troca a partir da direita.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">do</span>
			j--;
		<span class="keyword">while</span>(pivot &lt; items[j]);

</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Se os índices não se cruzaram, é necessário trocar os valores
dos respectivos itens e continuar o particionamento.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">if</span> (i &lt; j)
			swap(length, items, i, j);
	} <span class="keyword">while</span>(i &lt; j);
</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>O particionamento termina quando os índices <code>i</code> e <code>j</code> se cruzam.
Quando isso acontece, o índice <code>j</code> é o índice do primeiro item a
partir da direita que tem um valor menor ou igual ao <em>pivot</em>, podendo
por isso ser usado como posição definitiva do <em>pivot</em>. Se o valor de
<code>j</code> for igual a <code>first</code>, então o primeiro sub-segmento está vazio e o
<em>pivot</em> está na sua posição correcta, pelo não é necessário trocar a
sua posição nem proceder a qualquer ordenação do sub-segmento
esquerdo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span>(j != first) {
</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>Trocamos os valores dos itens <code>first</code> e <code>j</code>, para que o
<em>pivot</em> fique na posição definitiva, ou seja, na posição <code>j</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		swap(length, items, first, j);

</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <h5>Invocação recursiva do algoritmo</h5>
<p>Feito o particionamento, aplica-se recursivamente o mesmo
algoritmo a cada um dos sub-segmentos.</p>

            </div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>Invocação do mesmo algoritmo para ordenação do sub-segmento
esquerdo, entre <code>first</code> e <code>j</code> - 1. (O <em>pivot</em> está na posição
<code>j</code>.)</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		quicksort_segment(length, items, first, j - <span class="number">1</span>);
	}
</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Invocação do mesmo algoritmo para ordenação do sub-segmento direito,
entre <code>j</code> + 1 e <code>last</code>. (O <em>pivot</em> está na posição <code>j</code>.)</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	quicksort_segment(length, items, j + <span class="number">1</span>, last);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h4>Rotina de ordenação rápida</h4>
<p>Esta rotina não é recursiva, recorrendo ao procedimento recursivo definido
acima para efectuar a ordenação rápida.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> quicksort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Invocamos o procedimento recursivo de ordenação de um segmento do
<em>array</em> passando-lhe como posições extremas do segmento a ordenar os
valores 0 e <code>length</code> - 1, ou seja, indicando que pretendemos ordenar
o <em>array</em> no seu todo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	quicksort_segment(length, items, <span class="number">0</span>, length - <span class="number">1</span>);

</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Retornamos devolvendo <code>false</code>, i.e., assinalando o sucesso da
ordenação.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <h3>Ordenação rápida ou <em>quicksort</em> (com contagem de operações)</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">static</span> <span class="keyword">void</span> quicksort_segment_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
					<span class="keyword">const</span> <span class="keyword">int</span> first, <span class="keyword">const</span> <span class="keyword">int</span> last,
					<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);
	assert(<span class="number">0</span> &lt;= first);
	assert(last &lt; length);

	<span class="keyword">if</span> (first &gt;= last)
		<span class="keyword">return</span>;

	<span class="keyword">int</span> i = first;
	<span class="keyword">int</span> j = last + <span class="number">1</span>;
	counts-&gt;comparisons++;
	<span class="keyword">if</span> (items[first] &gt; items[last])
		swap_and_count(length, items, first, last, counts);
	<span class="keyword">const</span> <span class="keyword">double</span> pivot = items[first];
	<span class="keyword">do</span> {
		<span class="keyword">do</span> {
			i++;
			counts-&gt;comparisons++;
		} <span class="keyword">while</span>(items[i] &lt; pivot);
		<span class="keyword">do</span> {
			j--;
			counts-&gt;comparisons++;
		} <span class="keyword">while</span>(pivot &lt; items[j]);
		<span class="keyword">if</span> (i &lt; j)
			swap_and_count(length, items, i, j, counts);
	} <span class="keyword">while</span>(i &lt; j);
	<span class="keyword">if</span>(j != first) {
		swap_and_count(length, items, first, j, counts);
		quicksort_segment_and_count(length, items, first, j - <span class="number">1</span>, counts);
	}
	quicksort_segment_and_count(length, items, j + <span class="number">1</span>, last, counts);
}

<span class="keyword">bool</span> quicksort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	quicksort_segment_and_count(length, items, <span class="number">0</span>, length - <span class="number">1</span>, counts);

	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <h3>Ordenação por fusão ou <em>merge sort</em></h3>
<p>A ordenação por fusão é implementada recorrendo a:</p>
<ul>
<li>um procedimento auxiliar <code>merge_sort_segment()</code>, recursivo, que ordena
um segmento de <em>array</em> recorrendo a um <em>array</em> auxiliar com a mesma
dimensão do <em>array</em> a ordenar,</li>
<li>um procedimento auxiliar <code>merge()</code>, não recursivo, que funde num único
segmento ordenado de <em>array</em>  dois sub-segmentos ordenados e adjacentes de
<em>array</em>, e  </li>
<li>uma rotina <code>merge_sort()</code>, não recursiva, que constrói um <em>array</em> auxiliar
e invoca o procedimento auxiliar <code>merge_sort_segment()</code> passando-lhe o
<em>array</em> a ordenar e o <em>array</em> auxiliar e especificando o array completo
como segmento a ordenar.</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <h4>Procedimento não recursivo auxiliar de fusão de segmentos</h4>

            </div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Procedimento auxiliar, não recursivo, que funde num único segmento ordenado
os dois sub-segmentos adjacentes do <em>array</em> <code>items</code> com comprimento <code>length</code>
com início no índice <code>left</code> e fim no índice <code>middle</code>, o primeiro, e com
início no índice <code>middle</code> + 1 e fim no índice <code>right</code>, o segundo. A fusão é
feita recorrendo a um <em>array</em> auxiliar <code>temporary</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">static</span> <span class="keyword">void</span> merge(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
		<span class="keyword">double</span> temporary[length],
		<span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> middle, <span class="keyword">const</span> <span class="keyword">int</span> right)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || temporary != NULL);
	assert(<span class="number">0</span> &lt;= left &amp;&amp; left &lt; length);
	assert(<span class="number">0</span> &lt;= right &amp;&amp; right &lt; length);
	assert(left &lt;= middle &amp;&amp; middle &lt; right);

</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Note que, recorrendo a apenas uma comparação adicional por fusão,
podemos melhorar substancialmente a eficiência deste algoritmo
<em>quando o array a ordenar já está ordenado</em>. Basta acrescentar a
seguinte instrução condicional no início do procedimento:</p>
<pre><code class="lang-C">if (items[middle] &lt;= items[middle + 1])
    return;</code></pre>

            </div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <h5>Fusão dos sub-segmentos</h5>
<p>A primeira fase da fusão ocorre enquanto não se esgotou nenhum dos
dois segmentos a fundir. Durante este ciclo, os itens são copiados
dos dois segmentos a fundir para o segmento resultante da fusão <em>mas
no array auxiliar</em>. Usamos três índices para o efeito.</p>

            </div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>O índice <code>i</code> percorre o primeiro sub-segmento a fundir, começando por
isso em <code>left</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">int</span> i = left;
</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>O índice <code>j</code> percorre o segundo sub-segmento a fundir, começando por
isso em <code>middle</code> + 1.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">int</span> j = middle + <span class="number">1</span>;
</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>O índice <code>k</code> percorre o segmento resultante da fusão, começando por
isso em <code>left</code>, tal como <code>i</code>. No entanto, note-se que os valores são
copiados para o segmento resultante da fusão <em>no array auxiliar</em>.
Só depois são copiados de volta para o <em>array</em> a ordenar.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">int</span> k = left;
</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>O ciclo decorre enquanto nenhum dos sub-segmentos se esgotar.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span> (; i &lt;= middle &amp;&amp; j &lt;= right; k++)
</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>O valor a colocar na posição <code>k</code> do <em>array</em> auxiliar é o
menor dos valores indexados por <code>i</code> e por <code>j</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">if</span> (items[i] &lt;= items[j])
</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Tendo-se copiado o item em <code>i</code> do primeiro sub-
segmento, incrementamos valor de <code>i</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>			temporary[k] = items[i++];
		<span class="keyword">else</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Tendo-se copiado o item em <code>j</code> do segundo sub-
segmento, incrementamos valor de <code>j</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>			temporary[k] = items[j++];

</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <h5>Cópia dos itens remanescentes do primeiro sub-segmento</h5>

            </div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Quando o ciclo acima termina, pelo menos um dos sub-segmentos está
esgotado. Este primeiro ciclo lida com os itens do primeiro segmento
que não chegaram a ser copiados para o <em>array</em> temporário. Se o
primeiro segmento se tiver esgotado no ciclo anterior, então não terá
qualquer efeito. Para evitar a realização de duas cópias dos valores
destes itens, primeiro para o <em>array</em> auxiliar, depois para o <em>array</em>
a ordenar, copiamos estes itens para a sua posição no <em>array</em> a
ordenar, a partir da posição dada por <code>k</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span> (<span class="keyword">int</span> m = k; i &lt;= middle; i++, m++)
		items[m] = items[i];

</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Da mesma forma, o segundo sub-segmento do <em>array</em> pode não ter sido
esgotado no ciclo original. Se isso aconteceu, então os itens desse
sub-segmento <em>já estão na sua posição definitiva</em>.</p>

            </div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <h5>Recolocação dos itens fundidos no <em>array</em> a ordenar</h5>

            </div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Finalmente, é necessário copiar para o <em>array</em> a ordenar os itens
colocados no <em>array</em> auxiliar durante o primeiro ciclo, de fusão, que
decorreu enquanto nenhum dos sub-segmentos se esgotou.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; k; i++)
		items[i] = temporary[i];
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h4>Procedimento recursivo auxiliar de ordenação por fusão</h4>

            </div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Procedimento auxiliar que implementa o algoritmo de ordenação por fusão sobre
o segmento do <em>array</em> <code>items</code> (cujo comprimento é <code>length</code>) com início no
índice <code>left</code> e fim no índice <code>right</code>, recorrendo ao <em>array</em> auxiliar
<code>temporary</code> com o mesmo comprimento do <em>array</em> <code>items</code>. Este procedimento é
recursivo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">static</span> <span class="keyword">void</span> merge_sort_segment(<span class="keyword">const</span> <span class="keyword">int</span> length,
				<span class="keyword">double</span> items[length], <span class="keyword">double</span> temporary[length],
				<span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> right)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || temporary != NULL);
	assert(length == <span class="number">0</span> || left &lt;= right);
	assert(<span class="number">0</span> &lt;= left);
	assert(right &lt; length);

</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Se o segmento a ordenar tem comprimento inferior a 2, então está já
ordenado por natureza, pelo que terminamos imediatamente o
procedimento.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (left &gt;= right)
		<span class="keyword">return</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Calculamos o ponto médio do segmento em ordenação, dividindo-o em
dois sub-segmentos: o primeiro sub-segmento com índices entre <code>left</code>
e <code>middle</code> e o segundo sub-segmento com índices entre <code>middle</code> + 1 e
<code>right</code>. Se o segmento tiver um comprimento par, então os dois sub-
segmentos terão exactamente metade desse comprimento. Se o
comprimento do segmento for ímpar, então o primeiro sub-segmento terá
um comprimento maior em uma unidade que o segundo sub-segmento.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Aplicando uma estratégia <em>dividir para conquistar</em>, aplica-se o mesmo
procedimento, de forma recursiva, para ordenar <em>separadamente</em> cada
um dos sub-segmentos adjacentes obtidos.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	merge_sort_segment(length, items, temporary, left, middle);
	merge_sort_segment(length, items, temporary, middle + <span class="number">1</span>, right);

</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Neste ponto os dois sub-segmentos adjacentes já estão ordenados, pelo
que podemos fundi-los num único segmento recorrendo ao procedimento
de fusão.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	merge(length, items, temporary, left, middle, right);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <h4>Rotina de ordenação por fusão</h4>

            </div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>Esta rotina não é recursiva, recorrendo ao procedimento recursivo definido
acima para efectuar a ordenação por fusão.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">bool</span> merge_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p><em>Arrays</em> vazios ou com apenas um item estão sempre ordenados, pelo
que podemos terminar a execução da rotina.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Construímos um <em>array</em> auxiliar que será usado durante a fusão.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">double</span> *<span class="keyword">const</span> temporary = new_double_array_of(length);

</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>Verificamos a construção do novo <em>array</em> teve sucesso.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (temporary == NULL)
		<span class="keyword">return</span> <span class="keyword">true</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Invocamos o procedimento recursivo de ordenação de um segmento do
<em>array</em> passando-lhe como posições extremas do segmento a ordenar os
valores 0 e <code>length</code> - 1, ou seja, indicando que pretendemos ordenar
o <em>array</em> no seu todo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	merge_sort_segment(length, items, temporary, <span class="number">0</span>, length - <span class="number">1</span>);

</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Libertamos o <em>array</em> auxiliar.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	free(temporary);

</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Retornamos devolvendo <code>false</code>, i.e., assinalando o sucesso da
ordenação.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h3>Ordenação por fusão ou <em>merge sort</em> (com contagem de operações)</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">static</span> <span class="keyword">void</span> merge_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">double</span> temporary[length],
			<span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> middle, <span class="keyword">const</span> <span class="keyword">int</span> right,
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || temporary != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);
	assert(<span class="number">0</span> &lt;= left &amp;&amp; left &lt; length);
	assert(<span class="number">0</span> &lt;= right &amp;&amp; right &lt; length);
	assert(left &lt;= middle &amp;&amp; middle &lt; right);

	<span class="keyword">int</span> i = left;
	<span class="keyword">int</span> j = middle + <span class="number">1</span>;
	<span class="keyword">int</span> k = left;
	<span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= right) {
		counts-&gt;comparisons++;
		counts-&gt;copies++;
		<span class="keyword">if</span> (items[i] &lt;= items[j])
			temporary[k++] = items[i++];
		<span class="keyword">else</span>
			temporary[k++] = items[j++];
	}

	<span class="keyword">while</span> (i &lt;= middle) {
		counts-&gt;copies++;
		temporary[k++] = items[i++];
	}

	<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; j; i++) {
		counts-&gt;copies++;
		items[i] = temporary[i];
	}
}

<span class="keyword">static</span> <span class="keyword">void</span> merge_sort_segment_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length,
					<span class="keyword">double</span> items[length],
					<span class="keyword">double</span> temporary[length],
					<span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> right,
					<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || temporary != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);
	assert(length == <span class="number">0</span> || left &lt;= right);
	assert(<span class="number">0</span> &lt;= left);
	assert(right &lt; length);

	<span class="keyword">if</span> (left &gt;= right)
		<span class="keyword">return</span>;

	<span class="keyword">int</span> middle = (right + left) / <span class="number">2</span>;

	merge_sort_segment_and_count(length, items, temporary,
				left, middle, counts);
	merge_sort_segment_and_count(length, items, temporary,
				middle + <span class="number">1</span>, right, counts);

	merge_and_count(length, items, temporary, left, middle, right, counts);
}

<span class="keyword">bool</span> merge_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">if</span> (length &lt;= <span class="number">1</span>)
		<span class="keyword">return</span> <span class="keyword">false</span>;

	<span class="keyword">double</span> *<span class="keyword">const</span> temporary = new_double_array_of(length);

	<span class="keyword">if</span> (temporary == NULL)
		<span class="keyword">return</span> <span class="keyword">true</span>;

	merge_sort_segment_and_count(length, items, temporary, <span class="number">0</span>, length - <span class="number">1</span>,
				counts);

	free(temporary);

	<span class="keyword">return</span> <span class="keyword">false</span>;
}

</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
