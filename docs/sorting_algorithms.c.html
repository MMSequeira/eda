<!DOCTYPE html>

<html>
<head>
  <title>sorting_algorithms.c</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script src="http://softwaremaniacs.org/media/soft/highlight/highlight.pack.js"></script>
  <script>
    hljs.tabReplace = '        ';
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="array_of_routines.c.html">
                array_of_routines.c
              </a>
            
              
              <a class="source" href="array_utils.h.html">
                array_utils.h
              </a>
            
              
              <a class="source" href="print.c.html">
                print.c
              </a>
            
              
              <a class="source" href="arrays_and_pointers.c.html">
                arrays_and_pointers.c
              </a>
            
              
              <a class="source" href="arrays_basics.c.html">
                arrays_basics.c
              </a>
            
              
              <a class="source" href="command_line.c.html">
                command_line.c
              </a>
            
              
              <a class="source" href="fibonacci.c.html">
                fibonacci.c
              </a>
            
              
              <a class="source" href="hello_world.c.html">
                hello_world.c
              </a>
            
              
              <a class="source" href="hello_world_correct.c.html">
                hello_world_correct.c
              </a>
            
              
              <a class="source" href="linked_list.c.html">
                linked_list.c
              </a>
            
              
              <a class="source" href="malloc_stuff.c.html">
                malloc_stuff.c
              </a>
            
              
              <a class="source" href="nans_and_other_oddities.c.html">
                nans_and_other_oddities.c
              </a>
            
              
              <a class="source" href="rationals_with_structs.c.html">
                rationals_with_structs.c
              </a>
            
              
              <a class="source" href="routine_pointers.c.html">
                routine_pointers.c
              </a>
            
              
              <a class="source" href="experiments.c.html">
                experiments.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.c.html">
                naive_sequence_of_longs.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.h.html">
                naive_sequence_of_longs.h
              </a>
            
              
              <a class="source" href="sequence_of_longs.c.html">
                sequence_of_longs.c
              </a>
            
              
              <a class="source" href="sequence_of_longs.h.html">
                sequence_of_longs.h
              </a>
            
              
              <a class="source" href="tests.c.html">
                tests.c
              </a>
            
              
              <a class="source" href="sizeof_and_arrays.c.html">
                sizeof_and_arrays.c
              </a>
            
              
              <a class="source" href="array_of_doubles.c.html">
                array_of_doubles.c
              </a>
            
              
              <a class="source" href="array_of_doubles.h.html">
                array_of_doubles.h
              </a>
            
              
              <a class="source" href="perform_experiments.c.html">
                perform_experiments.c
              </a>
            
              
              <a class="source" href="sorting_algorithms.c.html">
                sorting_algorithms.c
              </a>
            
              
              <a class="source" href="sorting_algorithms.h.html">
                sorting_algorithms.h
              </a>
            
              
              <a class="source" href="string_io.c.html">
                string_io.c
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>sorting_algorithms.c</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include "sorting_algorithms.h"</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;assert.h&gt;</span>

<span class="preprocessor">#include "array_of_doubles.h"</span>

<span class="keyword">const</span> <span class="keyword">struct</span> sorting_algorithm sorting_algorithms[] = {
	{ <span class="string">"bubble sort"</span>, bubble_sort, bubble_sort_and_count },
	{ <span class="string">"selection sort"</span>, selection_sort, selection_sort_and_count },
	{ <span class="string">"insertion sort"</span>, insertion_sort, insertion_sort_and_count },
	{ <span class="string">"Shell sort"</span>, shell_sort, shell_sort_and_count },
	{ <span class="string">"quicksort"</span>, quicksort, quicksort_and_count },
	{ <span class="string">"merge sort"</span>, merge_sort, merge_sort_and_count },
};

<span class="keyword">const</span> <span class="keyword">int</span> number_of_sorting_algorithms =
	<span class="keyword">sizeof</span>(sorting_algorithms) / <span class="keyword">sizeof</span>(sorting_algorithms[<span class="number">0</span>]);

<span class="keyword">static</span> <span class="keyword">void</span> swap(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
		<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j)
{
	assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; length);
	assert(<span class="number">0</span> &lt;= j &amp;&amp; j &lt; length);
	assert(items != NULL);

	<span class="keyword">const</span> <span class="keyword">double</span> original_item_i = items[i];
	items[i] = items[j];
	items[j] = original_item_i;
}

<span class="keyword">static</span> <span class="keyword">void</span> swap_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j,
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; length);
	assert(<span class="number">0</span> &lt;= j &amp;&amp; j &lt; length);
	assert(items != NULL);

	<span class="keyword">const</span> <span class="keyword">double</span> original_item_i = items[i];
	items[i] = items[j];
	items[j] = original_item_i;

	counts-&gt;swaps++;
	counts-&gt;copies += <span class="number">3</span>;
}

<span class="keyword">bool</span> bubble_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

	<span class="keyword">for</span> (<span class="keyword">int</span> unsorted = length; unsorted != <span class="number">1</span>; unsorted--)
		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != unsorted - <span class="number">1</span>; i++)
			<span class="keyword">if</span> (items[i] &gt; items[i + <span class="number">1</span>])
				swap(length, items, i, i + <span class="number">1</span>);

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">bool</span> bubble_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">for</span> (<span class="keyword">int</span> unsorted = length; unsorted != <span class="number">1</span>; unsorted--)
		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != unsorted - <span class="number">1</span>; i++) {
			counts-&gt;comparisons++;
			<span class="keyword">if</span> (items[i] &gt; items[i + <span class="number">1</span>])
				swap_and_count(length, items, i, i + <span class="number">1</span>, counts);
		}

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">bool</span> selection_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

	<span class="keyword">for</span> (<span class="keyword">int</span> sorted = <span class="number">0</span>; sorted != length - <span class="number">1</span>; sorted++) {
		<span class="keyword">int</span> i_of_smallest = sorted;
		<span class="keyword">for</span> (<span class="keyword">int</span> i = sorted + <span class="number">1</span>; i != length; i++)
			<span class="keyword">if</span> (items[i] &lt; items[i_of_smallest])
				i_of_smallest = i;
		<span class="keyword">if</span> (i_of_smallest != sorted)
			swap(length, items, sorted, i_of_smallest);
	}

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">bool</span> selection_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">for</span> (<span class="keyword">int</span> sorted = <span class="number">0</span>;
		sorted != length - <span class="number">1</span>;
		sorted++) {
		<span class="keyword">int</span> i_of_smallest = sorted;
		<span class="keyword">for</span> (<span class="keyword">int</span> i = sorted + <span class="number">1</span>; i != length; i++) {
			counts-&gt;comparisons++;
			<span class="keyword">if</span> (items[i] &lt; items[i_of_smallest])
				i_of_smallest = i;
		}
		<span class="keyword">if</span> (i_of_smallest != sorted)
			swap_and_count(length, items,
					sorted, i_of_smallest, counts);
	}

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">bool</span> insertion_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

	<span class="keyword">for</span> (<span class="keyword">int</span> sorted = <span class="number">1</span>; sorted != length; sorted++) {
		<span class="keyword">const</span> <span class="keyword">double</span> item_to_insert = items[sorted];
		<span class="keyword">int</span> i = sorted;
		<span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; item_to_insert &lt; items[i - <span class="number">1</span>]) {
			items[i] = items[i - <span class="number">1</span>];
			i--;
		}
		<span class="keyword">if</span> (i != sorted)
			items[i] = item_to_insert;
	}

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">bool</span> insertion_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">for</span> (<span class="keyword">int</span> sorted = <span class="number">1</span>; sorted != length; sorted++) {
		counts-&gt;copies++;
		<span class="keyword">const</span> <span class="keyword">double</span> item_to_insert = items[sorted];
		<span class="keyword">int</span> i = sorted;
		<span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; item_to_insert &lt; items[i - <span class="number">1</span>]) {
			counts-&gt;comparisons++;
			counts-&gt;copies++;
			items[i] = items[i - <span class="number">1</span>];
			i--;
		}
		<span class="keyword">if</span> (i != <span class="number">0</span>)
			counts-&gt;comparisons++;
		<span class="keyword">if</span> (i != sorted) {
			counts-&gt;copies++;
			items[i] = item_to_insert;
		}
	}

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">bool</span> shell_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

	<span class="keyword">int</span> step = <span class="number">1</span>;
	<span class="keyword">while</span> (step &lt; length / <span class="number">3</span>)
		step = <span class="number">3</span> * step + <span class="number">1</span>;

	<span class="keyword">while</span> (step &gt;= <span class="number">1</span>) {
		<span class="keyword">for</span> (<span class="keyword">int</span> i = step; i != length; i++) {
			<span class="keyword">const</span> <span class="keyword">double</span> item_to_insert = items[i];
			<span class="keyword">int</span> j = i;
			<span class="keyword">while</span> (j &gt;= step &amp;&amp; item_to_insert &lt; items[j - step]) {
				items[j] = items[j - step];
				j -= step;
			}
			<span class="keyword">if</span> (j != i)
				items[j] = item_to_insert;
		}
		step /= <span class="number">3</span>;
	}

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">bool</span> shell_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">int</span> step = <span class="number">1</span>;
	<span class="keyword">while</span> (step &lt; length / <span class="number">3</span>)
		step = <span class="number">3</span> * step + <span class="number">1</span>;

	<span class="keyword">while</span> (step &gt;= <span class="number">1</span>) {
		<span class="keyword">for</span> (<span class="keyword">int</span> i = step; i != length; i++) {
			counts-&gt;copies++;
			<span class="keyword">const</span> <span class="keyword">double</span> item_to_insert = items[i];
			<span class="keyword">int</span> j = i;
			<span class="keyword">while</span> (j &gt;= step &amp;&amp; item_to_insert &lt; items[j - step]) {
				counts-&gt;comparisons++;
				counts-&gt;copies++;
				items[j] = items[j - step];
				j -= step;
			}
			<span class="keyword">if</span> (j &gt;= step)
				counts-&gt;comparisons++;
			<span class="keyword">if</span> (j != i) {
				counts-&gt;copies++;
				items[j] = item_to_insert;
			}
		}
		step /= <span class="number">3</span>;
	}

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">static</span> <span class="keyword">void</span> quicksort_segment(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">const</span> <span class="keyword">int</span> first, <span class="keyword">const</span> <span class="keyword">int</span> last)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(<span class="number">0</span> &lt;= first);
	assert(last &lt; length);

	<span class="keyword">if</span> (first &gt;= last)
		<span class="keyword">return</span>;

	<span class="keyword">int</span> i = first;
	<span class="keyword">int</span> j = last + <span class="number">1</span>;
	<span class="keyword">if</span> (items[first] &gt; items[last])
		swap(length, items, first, last);
	<span class="keyword">double</span> pivot = items[first];
	<span class="keyword">do</span> {
		<span class="keyword">do</span>
			i++;
		<span class="keyword">while</span>(items[i] &lt; pivot);
		<span class="keyword">do</span>
			j--;
		<span class="keyword">while</span>(pivot &lt; items[j]);
		<span class="keyword">if</span> (i &lt; j)
			swap(length, items, i, j);
	} <span class="keyword">while</span>(i &lt; j);
	<span class="keyword">if</span>(j != first) {
		swap(length, items, first, j);
		quicksort_segment(length, items, first, j - <span class="number">1</span>);
	}
	quicksort_segment(length, items, j + <span class="number">1</span>, last);
}

<span class="keyword">bool</span> quicksort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

	quicksort_segment(length, items, <span class="number">0</span>, length - <span class="number">1</span>);

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">static</span> <span class="keyword">void</span> quicksort_segment_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
					<span class="keyword">const</span> <span class="keyword">int</span> first, <span class="keyword">const</span> <span class="keyword">int</span> last,
					<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);
	assert(<span class="number">0</span> &lt;= first);
	assert(last &lt; length);

	<span class="keyword">if</span> (first &gt;= last)
		<span class="keyword">return</span>;

	<span class="keyword">int</span> i = first;
	<span class="keyword">int</span> j = last + <span class="number">1</span>;
	counts-&gt;comparisons++;
	<span class="keyword">if</span> (items[first] &gt; items[last])
		swap_and_count(length, items, first, last, counts);
	<span class="keyword">double</span> pivot = items[first];
	<span class="keyword">do</span> {
		<span class="keyword">do</span> {
			i++;
			counts-&gt;comparisons++;
		} <span class="keyword">while</span>(items[i] &lt; pivot);
		<span class="keyword">do</span> {
			j--;
			counts-&gt;comparisons++;
		} <span class="keyword">while</span>(pivot &lt; items[j]);
		<span class="keyword">if</span> (i &lt; j)
			swap_and_count(length, items, i, j, counts);
	} <span class="keyword">while</span>(i &lt; j);
	<span class="keyword">if</span>(j != first) {
		swap_and_count(length, items, first, j, counts);
		quicksort_segment_and_count(length, items, first, j - <span class="number">1</span>, counts);
	}
	quicksort_segment_and_count(length, items, j + <span class="number">1</span>, last, counts);
}

<span class="keyword">bool</span> quicksort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	quicksort_segment_and_count(length, items, <span class="number">0</span>, length - <span class="number">1</span>, counts);

	<span class="keyword">return</span> <span class="keyword">true</span>;
}


<span class="keyword">static</span> <span class="keyword">void</span> merge(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
		<span class="keyword">double</span> temporary[length],
		<span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> middle, <span class="keyword">const</span> <span class="keyword">int</span> right)
{
	<span class="keyword">int</span> i = left;
	<span class="keyword">int</span> j = middle + <span class="number">1</span>;
	<span class="keyword">int</span> k = left;
	<span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= right)
		<span class="keyword">if</span> (items[i] &lt;= items[j])
			temporary[k++] = items[i++];
		<span class="keyword">else</span>
			temporary[k++] = items[j++];

	<span class="keyword">for</span> (<span class="keyword">int</span> m = k; i &lt;= middle; i++, m++)
		items[m] = items[i];

	<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; k; i++)
		items[i] = temporary[i];
}

<span class="keyword">static</span> <span class="keyword">void</span> merge_sort_segment(<span class="keyword">const</span> <span class="keyword">int</span> length,
			<span class="keyword">double</span> items[length], <span class="keyword">double</span> temporary[length],
			<span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> right)
{
	<span class="keyword">if</span> (left &gt;= right)
		<span class="keyword">return</span>;

	<span class="keyword">int</span> middle = (right + left) / <span class="number">2</span>;

	merge_sort_segment(length, items, temporary, left, middle);
	merge_sort_segment(length, items, temporary, middle + <span class="number">1</span>, right);

	merge(length, items, temporary, left, middle, right);
}

<span class="keyword">bool</span> merge_sort(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length])
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);

	<span class="keyword">double</span> *<span class="keyword">const</span> temporary = new_double_array_of(length);

	<span class="keyword">if</span> (temporary == NULL)
		<span class="keyword">return</span> <span class="keyword">false</span>;

	merge_sort_segment(length, items, temporary, <span class="number">0</span>, length - <span class="number">1</span>);

	free(temporary);

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">static</span> <span class="keyword">void</span> merge_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">double</span> temporary[length],
			<span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> middle, <span class="keyword">const</span> <span class="keyword">int</span> right,
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	<span class="keyword">int</span> i = left;
	<span class="keyword">int</span> j = middle + <span class="number">1</span>;
	<span class="keyword">int</span> k = left;
	<span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= right) {
		counts-&gt;comparisons++;
		counts-&gt;copies++;
		<span class="keyword">if</span> (items[i] &lt;= items[j])
			temporary[k++] = items[i++];
		<span class="keyword">else</span>
			temporary[k++] = items[j++];
	}

	<span class="keyword">while</span> (i &lt;= middle) {
		counts-&gt;copies++;
		temporary[k++] = items[i++];
	}

	<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; j; i++) {
		counts-&gt;copies++;
		items[i] = temporary[i];
	}
}

<span class="keyword">static</span> <span class="keyword">void</span> merge_sort_segment_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length,
					<span class="keyword">double</span> items[length],
					<span class="keyword">double</span> temporary[length],
					<span class="keyword">const</span> <span class="keyword">int</span> left, <span class="keyword">const</span> <span class="keyword">int</span> right,
					<span class="keyword">struct</span> algorithm_counts* counts)
{
	<span class="keyword">if</span> (left &gt;= right)
		<span class="keyword">return</span>;

	<span class="keyword">int</span> middle = (right + left) / <span class="number">2</span>;

	merge_sort_segment_and_count(length, items, temporary,
				left, middle, counts);
	merge_sort_segment_and_count(length, items, temporary,
				middle + <span class="number">1</span>, right, counts);

	merge_and_count(length, items, temporary, left, middle, right, counts);
}

<span class="keyword">bool</span> merge_sort_and_count(<span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">double</span> items[length],
			<span class="keyword">struct</span> algorithm_counts* counts)
{
	assert(length &gt;= <span class="number">0</span>);
	assert(length == <span class="number">0</span> || items != NULL);
	assert(length == <span class="number">0</span> || counts != NULL);

	<span class="keyword">double</span> *<span class="keyword">const</span> temporary = new_double_array_of(length);

	<span class="keyword">if</span> (temporary == NULL)
		<span class="keyword">return</span> <span class="keyword">false</span>;

	merge_sort_segment_and_count(length, items, temporary, <span class="number">0</span>, length - <span class="number">1</span>,
				counts);

	free(temporary);

	<span class="keyword">return</span> <span class="keyword">true</span>;
}

</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
