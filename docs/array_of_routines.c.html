<!DOCTYPE html>

<html>
<head>
  <title>`array_of_routines.c` &ndash; Ponteiros para rotinas e _arrays_</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script src="http://softwaremaniacs.org/media/soft/highlight/highlight.pack.js"></script>
  <script>
    hljs.tabReplace = '        ';
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="array_of_routines.c.html">
                array_of_routines.c
              </a>
            
              
              <a class="source" href="array_utils.h.html">
                array_utils.h
              </a>
            
              
              <a class="source" href="print.c.html">
                print.c
              </a>
            
              
              <a class="source" href="arrays_and_pointers.c.html">
                arrays_and_pointers.c
              </a>
            
              
              <a class="source" href="arrays_basics.c.html">
                arrays_basics.c
              </a>
            
              
              <a class="source" href="command_line.c.html">
                command_line.c
              </a>
            
              
              <a class="source" href="fibonacci.c.html">
                fibonacci.c
              </a>
            
              
              <a class="source" href="hello_world.c.html">
                hello_world.c
              </a>
            
              
              <a class="source" href="hello_world_correct.c.html">
                hello_world_correct.c
              </a>
            
              
              <a class="source" href="linked_list.c.html">
                linked_list.c
              </a>
            
              
              <a class="source" href="malloc_stuff.c.html">
                malloc_stuff.c
              </a>
            
              
              <a class="source" href="nans_and_other_oddities.c.html">
                nans_and_other_oddities.c
              </a>
            
              
              <a class="source" href="rationals_with_structs.c.html">
                rationals_with_structs.c
              </a>
            
              
              <a class="source" href="routine_pointers.c.html">
                routine_pointers.c
              </a>
            
              
              <a class="source" href="experiments.c.html">
                experiments.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.c.html">
                naive_sequence_of_longs.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.h.html">
                naive_sequence_of_longs.h
              </a>
            
              
              <a class="source" href="sequence_of_longs.c.html">
                sequence_of_longs.c
              </a>
            
              
              <a class="source" href="sequence_of_longs.h.html">
                sequence_of_longs.h
              </a>
            
              
              <a class="source" href="tests.c.html">
                tests.c
              </a>
            
              
              <a class="source" href="sizeof_and_arrays.c.html">
                sizeof_and_arrays.c
              </a>
            
              
              <a class="source" href="string_io.c.html">
                string_io.c
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1><code>array_of_routines.c</code> &ndash; Ponteiros para rotinas e <em>arrays</em></h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Este programa ilustra uma forma particular de usar <a href="routine_pointers.c.html">ponteiros para
rotinas</a>: guardando-os dentro de um <em>array</em>. Para
informação especificamente sobre ponteiros para rotinas, sua utilização e
particularidades da sua implementação na linguagem C, ver
<a href="routine_pointers.c.html">routine_pointers.c</a>.</p>
<p>Optámos por omitir os comentários de documentação do <a href="doxygen.org">Doxygen</a>,
ao contrário do que tem sido nosso hábito.</p>
<h2>Inclusões</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>As inclusões usuais de ficheiros de cabeçalho, para poder usar o procedimento
<code>printf</code> de escrita no ecrã e para poder devolver <code>EXIT_SUCCESS</code> no final do
programa.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2>Definição das rotinas a guardar no <em>array</em></h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Todos os itens de um <em>array</em> em C têm de ser do mesmo tipo. Neste caso o
<em>array</em> guardará ponteiros para rotinas, que pode isso precisam de ter todos
o mesmo tipo. Ora, o tipo de um ponteiro para um rotina inclui a <em>assinatura</em>
completa da rotina, com excepção dos nomes da rotina e dos seus parâmetros.
Ou seja, inclui:</p>
<ul>
<li>A sequência dos tipos dos parâmetros da rotina.</li>
<li>O tipo de devolução da rotina.</li>
</ul>
<p>No nosso caso, todas as rotinas serão funções com dois parâmetros do tipo
<code>int</code> e devolvendo também um <code>int</code>. Tratando-se de um mero exemplo, optámos
por guardar no <em>array</em> apenas quatro funções, correspondendo às quatro
operações aritméticas básicas.</p>
<h3>Definição da função <code>sum()</code></h3>
<p>Devolve a soma dos seus dois argumentos.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> sum(<span class="keyword">int</span> first, <span class="keyword">int</span> second)
{
	<span class="keyword">return</span> first + second;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3>Definição da função <code>subtraction()</code></h3>
<p>Devolve a diferença entre os seus dois argumentos.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> subtraction(<span class="keyword">int</span> first, <span class="keyword">int</span> second)
{
	<span class="keyword">return</span> first - second;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h3>Definição da função <code>product()</code></h3>
<p>Devolve o produto dos seus dois argumentos.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> product(<span class="keyword">int</span> first, <span class="keyword">int</span> second)
{
	<span class="keyword">return</span> first * second;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h3>Definição da função <code>product()</code></h3>
<p>Devolve o quociente do seu primeiro argumento quando dividido pelo seu
segundo argumento.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> division(<span class="keyword">int</span> first, <span class="keyword">int</span> second)
{
	<span class="keyword">return</span> first / second;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h2>Definição do <em>array</em> de operações</h2>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>O <em>array</em> será definido de forma a ser constante e global. A opção pela
constância do <em>array</em> prende-se com o seu carácter global. É que, se a
utilização de variáveis globais é geralmente um má prática, por introduzir
formas subtis e pouco evidentes de comunicação entre troços distantes de um
programa, já a utilização de constantes globais não sofre do mesmo problema,
sendo por isso a sua utilização aconselhável em muitas circunstâncias.</p>
<p>A definição do <em>array</em> de ponteiros para as funções definidas é difícil de
perceber, devido à sintaxe peculiar do C. Há, no entanto, uma forma de
interpretação que torna a tarefa de compreender esta definição bem mais
simples: a definição de uma entidade em C reflecte a sua utilização no resto
do código. Por exemplo, se definirmos uma variável <code>an_int</code> como sendo do
tipo <code>int</code>, então poderemos usá-la no código, por exemplo, numa atribuição a
uma outra variável do mesmo tipo, da seguinte forma:</p>
<pre><code class="lang-C">// Definition of another_int and an_int...
...
// Use of the variables:
another_int = an_int;</code></pre>
<p>Ou seja, escrevendo <code>an_int</code> obtemos num <code>int</code>. A definição de <code>an_int</code>
reflecte esse facto: começa por se dizer o tipo resultante, neste caso <code>int</code>,
escreve-se depois a expressão que resulta nesse tipo, neste caso simplesmente
<code>an_int</code>, e finalmente termina-se a instrução de definição com o terminador
<code>;</code>:</p>
<pre><code class="lang-C">int an_int;</code></pre>
<p>ou, procedendo a uma inicialização durante a definição da variável,</p>
<pre><code class="lang-C">int an_int = 3;
an_int = 0; // valid: assignment changing the the value of the variable.</code></pre>
<p>Se em vez de uma variável pretendêssemos uma constante <code>a_constant_int</code>,
bastaria dizer que a expressão de <code>a_constant_int</code> resultaria num inteiro
constante:</p>
<pre><code class="lang-C">int const a_constant_int = 3;
a_constant_int = 0; // invalid: cannot change a constant!</code></pre>
<p>O C permite trocar a posição do qualificador <code>const</code>, que se pode colocar,
por isso, na sua posição mais habitual:</p>
<pre><code class="lang-C">const int a_constant_int = 3;
a_constant_int = 0; // invalid: cannot change a constant!</code></pre>
<p>Suponha-se agora uma variável <code>pointer_to_an_int</code> que é um ponteiro para
<code>int</code>, ou seja, que guarda o endereço de um <code>int</code>. Assumindo que a variável
contém um endereço válido, como se pode aceder ao inteiro por ela apontado?
Fácil: usando o operador conteúdo, ou de «desreferenciação», <code>*</code>. Por
exemplo:</p>
<pre><code class="lang-C">// Definition and initialization of an_int:
int an_int = 3;
// Definition of pointer_to_an_int:
...
// Assignment of the address of an_int to the pointer pointer_to_an_int:
pointer_to_an_int = &amp;an_int;
// Definition of another_int:
int another_int;
// Assignment of the contents of the integer pointed by pointer_to_an_int
// to variable another_int: 
another_int = *pointer_to_an_int;</code></pre>
<p>Ou seja, escrevendo <code>*pointer_to_an_int</code> obtemos um <code>int</code>. A definição de
<code>pointer_to_an_int</code> reflecte esse facto: começa por se dizer o tipo
resultante, neste caso <code>int</code>, escreve-se depois a expressão que resulta nesse
tipo, neste caso <code>*pointer_to_an_int</code>, e finalmente termina-se a instrução
de definição com o terminador <code>;</code>:</p>
<pre><code class="lang-C">int *pointer_to_an_int;</code></pre>
<p>ou, procedendo a uma inicialização durante a definição da variável,</p>
<pre><code class="lang-C">int *pointer_to_an_int = &amp;an_int;
pointer_to_an_int = &amp;some_other_int; // valid: assignment changes pointer.</code></pre>
<p>Se em vez de uma variável pretendêssemos uma constante
<code>constant_pointer_to_an_int</code>, bastaria dizer que a expressão
<code>constant_pointer_to_an_int</code> resultaria num ponteiro constante para <code>int</code>:</p>
<pre><code class="lang-C">int *const constant_pointer_to_an_int = &amp;an_int;
constant_pointer_to_an_int =
        &amp;some_other_int; // invalid: cannot change the constant pointer!</code></pre>
<p>Estranho? Nem por isso. Como queremos que <code>constant_pointer_to_an_int</code> seja
um ponteiro constante para <code>int</code>, temos de colocar o qualificador após o <code>*</code>. Se colocássemos o qualificador <code>const</code> antes do <code>*</code> estaríamos a dizer que
a expressão <code>*constant_pointer_to_an_int</code> tinha o tipo <code>int const</code> (ou <code>const
int</code>, que é o mesmo). Ou seja, estaríamos a dizer que o ponteiro em si era
variável, mas apontava para <code>int</code> constantes, que é como quem diz que os
<code>int</code> apontados não poderiam ser alterados através do ponteiro. Vamos
experimentar? Aqui vai:</p>
<pre><code class="lang-C">const int *pointer_to_a_constant_int = &amp;an_int;
*pointer_to_a_constant_int =
        0; // invalid: cannot change pointed constant int.
pointer_to_a_constant_int =
        &amp;some_other_int; // valid: assignment changes pointer.</code></pre>
<p>Podemos mesmo combinar as duas formas e definir um ponteiro constante para um
<code>int</code> constante:</p>
<pre><code class="lang-C">const int *const constant_pointer_to_a_constant_int = &amp;an_int;
*constant_pointer_to_a_constant_int =
        0; // invalid: cannot change pointed constant int.
constant_pointer_to_a_constant_int =
        &amp;some_other_int; // invalid: cannot change the constant pointer!</code></pre>
<p>Suponha-se agora que pretendemos definir um <em>array</em> de 10 <code>int</code> chamado
<code>ten_ints</code>. Depois de o definir, podemos usá-lo em expressões de indexação,
obtendo-se inteiros no processo:</p>
<pre><code class="lang-C">// Definition of ten_ints with values 20 down to 11:
...
// Definition of an_int:
int an_int;
// Assignment of the value of the first int in array ten_ints to variable
// an_int:
an_int = ten_ints[0];</code></pre>
<p>Ou seja, escrevendo <code>ten_ints[</code><em>n</em><code>]</code>, com <em>n</em> entre 0 e 9, obtemos um <code>int</code>.
A definição de <code>ten_ints</code> reflecte esse facto: começa por se dizer o tipo
resultante, neste caso <code>int</code>, escreve-se depois a expressão que resulta nesse
tipo, neste caso <code>ten_ints[10]</code>, e finalmente termina-se a instrução de
definição com o terminador <code>;</code>. Tratando-se da definição de um <em>array</em>, o que
colocamos dentro dos parênteses rectos é o número de itens do <em>array</em>, ou
seja, o seu comprimento:</p>
<pre><code class="lang-C">int ten_ints[10];</code></pre>
<p>ou, procedendo a uma inicialização durante a definição do <em>array</em>,</p>
<pre><code class="lang-C">int ten_ints[10] = {
        20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 11
};
ten_ints[0] = 0; // valid: assignment changes first item.</code></pre>
<p>Usando-se um inicializador, podemos deixar a tarefa de contar o número de
itens ao compilador. Assim, poderíamos ter definido o <em>array</em> como se segue:</p>
<pre><code class="lang-C">int ten_ints[] = {
        20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 11
};</code></pre>
<p>Se se pretender que os itens de um <em>array</em> <code>ten_constant_ints</code> sejam
constantes, ou seja, que as expressões <code>ten_constant_ints[</code><em>n</em><code>]</code> sejam do
tipo <code>const int</code>, então temos de definir o <em>array</em> como se segue:</p>
<pre><code class="lang-C">const int ten_constant_ints[10] = {
        20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 11
};
ten_constant_ints[0] = 0; // invalid: cannot change the array items!</code></pre>
<p>Finalmente, suponhamos uma variável <code>pointer_to_funtion</code> que guarda o
endereço de uma função com dois parâmetros do tipo <code>int</code> e que devolve também
um <code>int</code>. Para invocar a função apontada por esta variável com os argumentos
2 e 3, por exemplo, temos de (a) desreferenciar o ponteiro usando o operador
<code>*</code> e (b) invocar a função resultante usando o operador de invocação, que
consiste num par de parênteses curvos <code>()</code> contendo a lista dos argumentos
separados por vírgulas. Como o operador de invocação <code>()</code> tem precedência
relativamente ao operador de desreferenciação <code>*</code> (ver <a href="http://bit.ly/147TVC2">tabela de precedência
e associatividade dos operadores do C e do C++ na
Wikipédia</a>), temos de garantir que este último é
aplicado ao ponteiro para a função antes do operador de invocação. Ou seja,
temos de escrever <code>(*pointer_to_function)(2, 3)</code>. O resultado desta invocação
é um <code>int</code>, uma vez que dissemos que a função tem dois parâmetros <code>int</code> e
devolve também um <code>int</code>. Por exemplo:</p>
<pre><code class="lang-C">// Definition of the sum() function:
int sum(int first, int second)
{
        return first + second;
}

// Definition of the subtraction() function:
int subtraction(int first, int second)
{
        return first - second;
}

// Definition of pointer_to_function pointing to the sum() function:
...
// Definition of an_int:
int an_int;
// Assignment of the result of the call to the sum function with arguments
// 2 and 3 through the pointer_to_function variable:
an_int = (*pointer_to_function)(2, 3);</code></pre>
<p>Ou seja, escrevendo <code>(*pointer_to_function)(</code><em>n</em><code>,</code><em>m</em><code>)</code>, com <em>n</em> e <em>m</em>
valores inteiros, obtemos um <code>int</code>. A definição de <code>pointer_to_function</code>
reflecte esse facto: começa por se dizer o tipo resultante, neste caso <code>int</code>,
escreve-se depois a expressão que resulta nesse tipo, neste caso
<code>(*pointer_to_function)(int, int)</code>, e finalmente termina-se a instrução de
definição com o terminador <code>;</code>. Tratando-se da definição de um ponteiro para
uma rotina, o que colocamos dentro dos parênteses curvos no local dos
argumentos é o tipo de cada um dos parâmetros da rotina:</p>
<pre><code class="lang-C">int (*pointer_to_function)(int, int);</code></pre>
<p>ou, procedendo a uma inicialização durante a definição do ponteiro,</p>
<pre><code class="lang-C">int (*pointer_to_function)(int, int) = &amp;sum;
pointer_to_function = &amp;subtraction; // valid: assignment changes pointer.
*pointer_to_function = ...; // invalid: routines are unchangeable.</code></pre>
<p>O C é simpático, assumindo que qualquer referência ao nome de uma rotina na
realidade se refere ao endereço dessa rotina. Assim, o código acima pode ser
simplificado:</p>
<pre><code class="lang-C">int (*pointer_to_function)(int, int) = sum;
pointer_to_function = subtraction; // valid: assignment changes pointer.</code></pre>
<p>Se pretendermos definir uma constante <code>constant_pointer_to_function</code>, então
teremos de preceder o nome da constante do qualificador <code>const</code>, da mesma
forma que anteriormente:</p>
<pre><code class="lang-C">int (*const constant_pointer_to_function)(int, int) = sum;
pointer_to_function =
        subtraction; // invalid: cannot change a constant pointer.</code></pre>
<p>Estamos finalmente em condições de perceber como definir o nosso <em>array</em> de
quatro ponteiros <em>constantes</em> para funções com dois parâmetros <code>int</code> e
devolvendo um <code>int</code>. Suponhamos que este <em>array</em> se chama <code>operators</code> e que o
seu primeiro item é o ponteiro (constante) para a função <code>sum()</code>. Então as
seguintes expressões têm os significados indicados:</p>
<ul>
<li><p><code>operators</code> - O <em>array</em> completo (que o C, salvo raras excepções, considera
como equivalente a um ponteiro para o seu primeiro item).</p>
</li>
<li><p><code>operators[0]</code> - O primeiro item do <em>array</em>, que é um ponteiro para a
função <code>sum()</code>.</p>
</li>
<li><p><code>*operators[0]</code> - O conteúdo da posição de memória apontada pelo primeiro
item do <em>array</em>, ou seja, a função <code>sum()</code> propriamente dita.</p>
</li>
<li><p><code>(*operators[0])(2, 3)</code> - O resultado da invocação da função <code>sum()</code>
apontada pelo primeiro item do <em>array</em> passando-lhe os argumentos 2 e 3, ou
seja, o valor 5. Note-se que a colocação dos parênteses curvos em torno de
<code>*operators[0]</code> é necessária porque o operador de invocação <code>()</code>, usado
neste caso com os operandos 2 e 3, <em>tem maior precedência que o operador
<code>*</code></em> (ver <a href="http://bit.ly/147TVC2">tabela de precedência e associatividade dos operadores do C e do
C++ na Wikipédia</a>).</p>
</li>
</ul>
<p>Ou seja, escrevendo <code>(*operators[</code><em>i</em><code>])(</code><em>n</em><code>,</code><em>m</em><code>)</code>, com <em>i</em> entre 0 e 3
e com <em>n</em> e <em>m</em> valores inteiros, obtemos um <code>int</code>. A definição de
<code>operators</code> reflecte esse facto: começa por se dizer o tipo resultante, neste
caso <code>int</code>, escreve-se depois a expressão que resulta nesse tipo, neste caso
<code>(*operators[4])(int, int)</code>, e finalmente termina-se a instrução de definição
com o terminador <code>;</code>. Tratando-se da definição de um <em>array</em>, colocamos entre
parênteses rectos o número de itens do <em>array</em>, neste caso 4. Tratando-se de
um <em>array</em> de ponteiros para rotinas, o que colocamos dentro dos parênteses
curvos no local dos argumentos é o tipo de cada um dos parâmetros da rotina,
neste caso dois <code>int</code>:</p>
<pre><code class="lang-C">int (*operations[4])(int, int);</code></pre>
<p>Uma vez que desejamos que os itens do <em>array</em> (os ponteiros) sejam
constantes, colocamos o qualificador <code>const</code> entre o <code>*</code> e o nome do <em>array</em>:</p>
<pre><code class="lang-C">int (*const operations[4])(int, int);</code></pre>
<p>Podemos inicializar o <em>array</em> usando um inicializador com os endereços das
várias funções:</p>
<pre><code class="lang-C">int (*const operations[4])(int, int) = {
        &amp;sum,
        &amp;subtraction,
        &amp;product,
        &amp;division
};</code></pre>
<p>Podemos omitir a indicação explícita do número de itens do <em>array</em>, deixando
ao compilador o trabalho de calcular o número de itens a partir do número de
itens no inicializador:</p>
<pre><code class="lang-C">int (*const operations[])(int, int) = {
        &amp;sum,
        &amp;subtraction,
        &amp;product,
        &amp;division
};</code></pre>
<p>Finalmente, tirando partido do facto de, salvo raras excepções, o C converter
qualquer referência ao nome de um rotina num ponteiro para essa mesma rotina,
podemos simplificar a definição anterior para a nossa versão definitiva:</p>
<pre><code class="lang-C">int (*const operations[])(int, int) = {
        sum,
        subtraction,
        product,
        division
};</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> (*<span class="keyword">const</span> operations[])(<span class="keyword">int</span>, <span class="keyword">int</span>) = {
	sum,
	subtraction,
	product,
	division
};

</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Usamos agora o truque usual para obter o número de itens de um <em>array</em>:
dividir o espaço de memória total ocupado pelo <em>array</em> pelo espaço ocupado
por cada um dos seus itens. Para isso usamos o operador <code>sizeof</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">const</span> <span class="keyword">int</span> number_of_operations =
	<span class="keyword">sizeof</span>(operations) /
	<span class="keyword">sizeof</span>(operations[<span class="number">0</span>]);

</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Definimos a rotina principal, onde experimentamos o conceito de <em>array</em> de
rotinas.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> main(<span class="keyword">void</span>)
{
</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Percorremos cada um dos itens do <em>array</em> <code>operations</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != number_of_operations; i++)
</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Invocamos com os argumentos 5 e 2 a função apontada por cada
item do <em>array</em>. O resultado será, naturalmente:</p>
<pre><code>Operation 0: 7
Operation 1: 3
Operation 2: 10
Operation 3: 2</code></pre>
<p>Note que, para invocar a função apontada pelo item <code>i</code> do
<em>array</em> <code>operations</code>, poderia parecer obrigatório usar o
operador <code>*</code>:</p>
<pre><code class="lang-C">printf(&quot;Operation %d: %d\n&quot;, i,
        (*operations[i])(5, 2));</code></pre>
<p>A linguagem C, no entanto, permite-nos omitir o operador <code>*</code>
e aplicar directamente o operador de invocação <code>()</code> ao
ponteiro para a função. Daí que o código apresentado seja</p>
<pre><code class="lang-C">printf(&quot;Operation %d: %d\n&quot;, i,
        operations[i](5, 2));</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>		printf(<span class="string">"Operation %d: %d\n"</span>, i,
			operations[i](<span class="number">5</span>, <span class="number">2</span>));

</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Terminamos assinalando sucesso.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> EXIT_SUCCESS;
}

</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
