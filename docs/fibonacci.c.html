<!DOCTYPE html>

<html>
<head>
  <title>`fibonacci.c` &ndash; Recursividade, iteração e algoritmos</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script src="http://softwaremaniacs.org/media/soft/highlight/highlight.pack.js"></script>
  <script>
    hljs.tabReplace = '        ';
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="array_of_routines.c.html">
                array_of_routines.c
              </a>
            
              
              <a class="source" href="array_utils.h.html">
                array_utils.h
              </a>
            
              
              <a class="source" href="print.c.html">
                print.c
              </a>
            
              
              <a class="source" href="arrays_and_pointers.c.html">
                arrays_and_pointers.c
              </a>
            
              
              <a class="source" href="arrays_basics.c.html">
                arrays_basics.c
              </a>
            
              
              <a class="source" href="command_line.c.html">
                command_line.c
              </a>
            
              
              <a class="source" href="fibonacci.c.html">
                fibonacci.c
              </a>
            
              
              <a class="source" href="hello_world.c.html">
                hello_world.c
              </a>
            
              
              <a class="source" href="hello_world_correct.c.html">
                hello_world_correct.c
              </a>
            
              
              <a class="source" href="linked_list.c.html">
                linked_list.c
              </a>
            
              
              <a class="source" href="malloc_stuff.c.html">
                malloc_stuff.c
              </a>
            
              
              <a class="source" href="nans_and_other_oddities.c.html">
                nans_and_other_oddities.c
              </a>
            
              
              <a class="source" href="rationals_with_structs.c.html">
                rationals_with_structs.c
              </a>
            
              
              <a class="source" href="routine_pointers.c.html">
                routine_pointers.c
              </a>
            
              
              <a class="source" href="experiments.c.html">
                experiments.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.c.html">
                naive_sequence_of_longs.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.h.html">
                naive_sequence_of_longs.h
              </a>
            
              
              <a class="source" href="sequence_of_longs.c.html">
                sequence_of_longs.c
              </a>
            
              
              <a class="source" href="sequence_of_longs.h.html">
                sequence_of_longs.h
              </a>
            
              
              <a class="source" href="tests.c.html">
                tests.c
              </a>
            
              
              <a class="source" href="sizeof_and_arrays.c.html">
                sizeof_and_arrays.c
              </a>
            
              
              <a class="source" href="array_of_doubles.c.html">
                array_of_doubles.c
              </a>
            
              
              <a class="source" href="array_of_doubles.h.html">
                array_of_doubles.h
              </a>
            
              
              <a class="source" href="perform_experiments.c.html">
                perform_experiments.c
              </a>
            
              
              <a class="source" href="sorting_algorithms.c.html">
                sorting_algorithms.c
              </a>
            
              
              <a class="source" href="sorting_algorithms.h.html">
                sorting_algorithms.h
              </a>
            
              
              <a class="source" href="string_io.c.html">
                string_io.c
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1><code>fibonacci.c</code> &ndash; Recursividade, iteração e algoritmos</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/**
 * \file fibonacci.c
 * \brief Illustrates possible implementations of the calculation of terms of
 * the Fibonacci sequence.
 *
 * Iterative and recursive implementations of the calculation of terms of
 * the Fibonacci sequence. These implementations are used to illustrate
 * iteration vs. recursion, and also to show how a naïve implementation of
 * recursion may lead to serious problems and how lookup tables can be used to
 * speed up calculations.
 */</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2>Coelhos, recursividade e iteração</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Ofereceram ao Sr. Fibonacci um casal de coelhos, recém-nascidos, de um
espécie curiosa: tornam-se férteis ao fim de um mês de vida, concebem logo
que possível, têm uma gestação de exactamente um mês, cada ninhada consiste
sempre num casalinho de coelhos. Nunca morrem. O Sr. Fibonacci preocupou-se:
teria comida que chegue para os coelhos? Pôs-se a calcular a evolução do
número de casais de coelhos ao longo do tempo:</p>
<ol>
<li><p>No mês zero o Sr. Fibonacci vivia feliz, sem qualquer coelho. Mal
calculava o seu destino...</p>
</li>
<li><p>No primeiro mês há um casal de coelhos inférteis.</p>
</li>
<li><p>No segundo mês há um casal de coelhos, já férteis e, claro está, com a
coelha no início da gestação de mais um casalinho.</p>
</li>
<li><p>No terceiro mês há o casal de coelhos original, fértil, e já no início da
gestação de mais um casalinho de coelhos. E há, claro está, um casal recém-
nascido e, por isso, infértil. Ou seja, há dois casais de coelhos, um fértil
e outro infértil.</p>
</li>
<li><p>No quarto mês há os dois casais do mês anterior, já férteis, adicionados
de um casal recém-nascido, resultado do acasalamento do único casal fértil do
mês anterior. Ou seja, há três casais de coelhos, dois férteis e um infértil.</p>
</li>
<li><p>No quinto mês há os três casais do mês anterior, já férteis, adicionados
de dois casais recém-nascidos, resultado do acasalamento entre os dois casais
férteis do mês anterior. Ou seja, há cinco casais de coelhos, três férteis e
dois inférteis.</p>
</li>
</ol>
<p>O Sr. Fibonacci concluiu rapidamente que, a partir do terceiro mês,</p>
<ul>
<li><p>o número de casais férteis num mês é sempre igual ao número total de casais
no mês anterior e</p>
</li>
<li><p>o número total de casais num mês é sempre igual à soma do número total de
casais existente no mês anterior com o número de casais recém-nascidos, que
é igual ao número de casais férteis no mês anterior e que, por isso, é
igual ao número total de casais existentes dois meses antes.</p>
</li>
</ul>
<p>Sendo <img src="http://bit.ly/ZCdcqY" alt="F(n)"> o número de casais de coelhos no mês
<img src="http://bit.ly/Z4ELdk" alt="n">, então, desde que <img src="http://bit.ly/10vWeOB" alt="n&gt;2">,
<img src="http://bit.ly/10zLPR3" alt="F(n)=F(n-2)+F(n-1)">. Quando
<img src="http://bit.ly/14HsgeM" alt="n=1"> ou <img src="http://bit.ly/YVICg2" alt="n=2">,
<img src="http://bit.ly/13V3GYG" alt="F(n)=1">. Ou seja, esta sucessão pode ser descrita de
forma <em>recursiva</em>, ou seja, definindo os termos da sucessão em função de
outros termos da mesma sucessão.</p>
<p>O que pretendemos aqui é implementar uma função que receba o mês como
argumento e devolva o número de casais existentes nesse mês. Como não
fornecemos apenas uma implementação, mas várias, com diferentes eficiências,
os nomes dessas funções não poderão ser simplesmente <code>fibonacci()</code>, incluindo
no seu nome um sufixo que identifica o tipo de implementação usado. Pode
argumentar-se que, sendo a eficiência parte da interface de um módulo, então
é razoável usar esses sufixos. No entanto, seria preferível, se o nosso
objectivo não fosse o estudo dos algoritmos em si, mas a criação de
ferramentas para utilização futura ou para disponibilização a terceiros, usar
sufixos que fossem reveladores da eficiência da função, e não da sua
implementação.</p>
<p>Antes, porém, de passar às implementações, é preciso dizer que o presente
oferecido ao Sr. Fibonacci está realmente envenenado. Com efeito, a sucessão
de Fibonacci cresce de forma extremamente rápida. Assim, no mês 120, ou seja,
dez anos depois da oferta do casal original, o número de casais a alimentar é
exactamente 5&thinsp;358&thinsp;359&thinsp;254&thinsp;990&thinsp;966&thinsp;640&thinsp;871&thinsp;840.
Este valor é demasiado grande para os <code>int</code> nas nossas máquinas habituais,
que têm 32 <em>bits</em>, ou mesmo para os <em>long</em>, com 64 <em>bits</em> nessas mesmas
máquinas. Por outro lado, a precisão limitada dos tipos de virgula flutuante
pode pôr problemas complicados ao cálculo dos termos da sucessão (já
tínhamos dito que dos tipos de vírgula flutuante se foge como diabo da
cruz?). O código abaixo recorre ao tipo <code>long</code>, numa tentativa de evitar que
se atinjam muito cedo os limites dos inteiros. É uma má solução, no entanto.
Uma boa solução passaria pela utilização de um tipo capaz de representar
números inteiros de dimensão arbitrária (desde que haja memória para o
guardar, bem entendido). A implementação de um tal tipo é um excelente
exercício de algoritmos e estruturas de dados, mas não o resolveremos aqui.</p>
<h2>Implementação</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Como se referiu, usamos <code>long</code> como tipo de devolução das funções de cálculo
dos termos da sucessão de Fibonacci. Será que isso adianta muito, em relação
à utilização de <em>int</em>? Fazendo algumas experiências, é fácil verificar que,
em máquinas em que os <code>int</code> têm 32 <em>bits</em>, ou seja, em máquinas em que o
maior valor representável num <code>int</code> é 2&thinsp;147&thinsp;483&thinsp;647, o
maior termo da sucessão de Fibonacci representável num <code>int</code> é o termo 46, ou
seja, <img src="http://bit.ly/XgffV7" alt="F(46)">, cujo valor é
1&thinsp;836&thinsp;311&thinsp;903. Isto é, usando <code>int</code> só conseguimos obter
valores correctos para os primeiros 47 termos da sucessão. Usando <code>long</code>, é
fácil verificar que, em máquinas em que os <code>long</code> têm 64 <em>bits</em>, ou seja, em
máquinas em que o maior valor representável num <code>long</code> é
9&thinsp;223&thinsp;372&thinsp;036&thinsp;854&thinsp;775&thinsp;807, o maior
termo da sucessão de Fibonacci representável num <code>long</code> é o termo 92, ou
seja, <img src="http://bit.ly/12kthcr" alt="F(92)">, cujo valor é
7&thinsp;540&thinsp;113&thinsp;804&thinsp;746&thinsp;346&thinsp;429. Isto é,
usando <code>long</code> só conseguimos obter valores correctos para os primeiros 93
termos da sucessão. Melhor que os 47 se se usasse <code>int</code>, mas ainda assim um
valor bem pequeno.</p>
<p>O maior termo calculável usando <code>long</code>, 92, deve ser usado nas pré-condições
das funções abaixo. Usar o valor literal nesse código é muito má ideia, pois
torna mais difícil a compreensão do código. Afinal, haverá que perceba
imediatamente o significado desse valor? Para resolver o problema definimos
uma constante para guardar esse valor. Uma vez que esta constante será usada
para dimensionar <em>arrays</em> que pretendemos inicializar usando as usuais listas
de inicializadores do C, não podemos usar a forma mais óbvia de definir
constantes em C, i.e., não podemos usar</p>
<pre><code class="lang-C">const int maximum_term_fitting_a_long = 92;</code></pre>
<p>tendo, pelo contrário de usar uma macro do pré-processador.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief The index of the largest term of the Fibonacci sequence that fits
 * within a `long`. */</span>
<span class="preprocessor">#define MAXIMUM_TERM_FITTING_A_LONG 92</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3>Inclusão de ficheiros de cabeçalho</h3>
<p>Incluímos os seguintes ficheiros de cabeçalho:</p>
<ul>
<li><p><code>stdio.h</code> &ndash; Para declaração do procedimento <code>printf()</code>.</p>
</li>
<li><p><code>stdlib.h</code> &ndash; Para definição da <em>macro</em> <code>EXIT_SUCCESS</code>.</p>
</li>
<li><p><code>time.h</code> &ndash; Para definição da função <code>clock()</code> e da macro
<code>CLOCKS_PER_SEC</code>.</p>
</li>
<li><p><code>assert.h</code> &ndash; Para definição da macro <code>assert()</code>.</p>
</li>
</ul>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;assert.h&gt;</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h3>Inclusão de ficheiros de cabeçalho próprios</h3>
<p>Incluímos apenas um ficheiro de cabeçalho «não oficial»:</p>
<ul>
<li><code>sequence_of_longs.h</code> &ndash; Para declaração do TAD (tipo abstracto de
dados) sucessão de <code>long</code> usada para guardar em memória dos termos da
sucessão já calculados.</li>
</ul>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include "sequence_of_longs.h"</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h3>Implementação recursiva «estúpida»</h3>
<h4>Documentação</h4>
<p>A documentação da função é feita no formato do
<a href="http://doxygen.org/">Doxygen</a>, como habitualmente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fiboncci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term \f$F_{\mathtt{n}}\f$ of the Fibonacci
 * sequence.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the [Fibonacci
 * sequence](http://mathworld.wolfram.com/FibonacciNumber.html), i.e.,
 * \f$F_{\mathtt{n}}\f$. It is assumed the sequence \f$F_n\f$ starts at
 * \f$n=0\f$, with value 0, followed by value 1, at \f$n=1\f$. That is, the
 * sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 * It can be shown that
 * \f[
 * F_n = \frac{\phi^n-\psi^n}{\sqrt{5}},
 * \f]
 * where \f$\phi=\frac{1+\sqrt{5}}{2}\f$ and \f$\psi=\frac{1-\sqrt{5}}{2}\f$,
 * and also that, even more simple,
 * \f[
 * F_n = \left[\frac{\phi^n}{\sqrt{5}}\right],
 * \f]
 * where \f$[\cdot]\f$ is the nearest integer function.
 *
 * The time taken by the function grows exponentially with `n`. More precisely,
 * the number of (recursive) executions of this function performed
 * while calculating \f$F_n\f$ by calling
 * `stupidly_recursive_fibonacci(`\f$n\f$`)` is \f$2F_{n+1}-1\f$ and the number
 * of aditions performed is \f$F_{n+1}-1\f$.
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h4>Definição</h4>
<p>Esta implementação segue a estratégia mais comum das soluções recursivas:
decompor o problema em problemas mais simples, resolver esses problemas mais
simples usando exactamente a mesma estratégia, recursivamente, e compor as
soluções dos subproblemas de modo a obter a solução do problema como um todo.
Uma solução recursiva, como esta, precisa de possuir casos de paragem (ou
casos especiais), para os quais a solução é imediata, não sendo necessária
qualquer decomposição adicional. A definição recursiva da sucessão de
Fibonacci aparenta adequar-se bem a esta estratégia:</p>
<p><img src="http://bit.ly/169sagW" alt="F(n)={0, se n = 0, 1, se n = 1, e F(n-2) + F(n-1), se n &gt;
1}"></p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> stupidly_recursive_fibonacci(<span class="keyword">int</span> n)
{
</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Em primeiro lugar, verificamos as pré-condições e lidamos com as
violações que forem detectadas.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Depois, lidamos com os dois casos especiais da sucessão. Estes casos
servem também para garantir que as invocações recursivas desta função
acabarão sempre por terminar (em tempo finito).</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n == <span class="number">0</span>)
		<span class="keyword">return</span> <span class="number">0L</span>;
	<span class="keyword">if</span> (n == <span class="number">1</span>)
		<span class="keyword">return</span> <span class="number">1L</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>O caso geral é simplesmente a devolução da soma dos termos anterior
da sucessão. Para os obter, invocamos a própria função com os dois
valores inteiros anteriores a <code>n</code>. O problema desta implenentação é
que se está a reduzir o problema de calcular
<img src="http://bit.ly/ZCdcqY" alt="F(n)"> aos subproblemas de calcular
<img src="http://bit.ly/14HrTAK" alt="F(n-2)"> e de calcular
<img src="http://bit.ly/13V2Vid" alt="F(n-1)">, <em>mas estes subproblemas não são
independentes!</em> Isso faz com que esta implementação seja muitíssimo
ineficiente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> stupidly_recursive_fibonacci(n - <span class="number">2</span>)
		+ stupidly_recursive_fibonacci(n - <span class="number">1</span>);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Para compreendemos bem a ineficiência desta implementação, vamos calcular
alguns valores interessantes.</p>
<p>Em primeiro lugar, uma revelação: a sucessão de Fibonacci pode ser expressa
de forma fechada. «Estamos aqui com tudo isto e a coisa resume-se a uma
fórmula fechada?», podem perguntar. Sim. Mas pode haver boas razões para não
recorrer a essa fórmula: ela obriga-nos a trabalhar com valores de vírgula
flutuante e, por isso, a lidar com as correspondentes limitações de precisão.
As nossas implementações, recorrendo a <em>long</em>, são exactas... Podem encontrar
informação sobre a sucessão de Fibonacci, e sobre a sua forma fechada, em
vários locais. Recomendamos os seguintes:</p>
<ul>
<li><p><a href="http://www.wolframalpha.com/input/?i=F_n">F_n</a> no
<a href="http://www.wolframalpha.com/">Wolfram|Alpha</a> - O Wolfram|Alpha é um motor
de pesquisa com a <a href="http://www.wolfram.com/">Wolfram</a> por trás (a mesma que
produz o maravilhoso
<a href="http://www.wolfram.com/mathematica/">Wolfram|Mathematica</a>) só podia ser
excelente. E é-o.</p>
</li>
<li><p><a href="http://mathworld.wolfram.com/FibonacciNumber.html">Fibonacci Number</a> no
<a href="http://mathworld.wolfram.com/">Wolfram|MathWorld</a> - O Wolfram|MathWorld é
uma enciclopédia matemática também com a garantia de qualidade da
<a href="http://www.wolfram.com/">Wolfram</a>. Outra excelente fonte de informação.</p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci number</a> na
<a href="http://en.wikipedia.org/">Wikipédia</a>.</p>
</li>
</ul>
<p>A forma fechada da sucessão de Fibonacci é</p>
<p><img src="http://bit.ly/10fxJ6c" alt="F_n=(phi^n - psi^n)/sqrt(5)">,</p>
<p>onde</p>
<p><img src="http://bit.ly/15hTKsW" alt="phi=(1+sqrt(5))/2">, que é chamado <em>número de ouro</em>,
e</p>
<p><img src="http://bit.ly/12Elq43" alt="psi=(1-sqrt(5))/2">.</p>
<p>Outra forma fechada é</p>
<p><img src="http://bit.ly/1254VAx" alt="F_n=arred(phi^n/sqrt(5))">,</p>
<p>onde</p>
<p><img src="http://bit.ly/10bSbcU" alt="arred(x)"></p>
<p>é a função que resulta no inteiro mais próximo ou arredondamento de
<img src="http://bit.ly/12ElMrk" alt="x">, sendo que em caso de empate entre dois inteiros
mais próximos se escolhe o inteiro que for par.</p>
<p>Ambas as formas mostram bem o que já tínhamos observado: o crescimento da
sucessão de Fibonacci é extremamente rápido. Mais precisamente, o crescimento
da sucessão de Fibonacci é <em>exponencial</em>, sendo a base da exponencial o
número de ouro e o expoente o número do termo da sucessão.</p>
<p>Vamos agora calcular o número de invocações da função <code>recursive_fibonacci()</code>
que ocorrem durante a cálculo de um dado termo <img src="http://bit.ly/Z4ELdk" alt="n"> da
sucessão de Fibonacci, ou seja, durante a execução da função que acabámos de
definir quando se lhe passa como argumento esse valor
<img src="http://bit.ly/Z4ELdk" alt="n">. Chamemos a esse número de invocações
<img src="http://bit.ly/139Mk7p" alt="N_n">.</p>
<p>Em primeiro lugar, é evidente que invocar <code>recursive_fibonacci()</code> com
<img src="http://bit.ly/Z4ELdk" alt="n"> como argumento leva a uma invocação inicial,
nomeadamente a que acabámos de referir, com <img src="http://bit.ly/Z4ELdk" alt="n"> como
argumento. Se o valor de <img src="http://bit.ly/Z4ELdk" alt="n"> for 0 ou 1, então não é
realizada qualquer outra invocação. Ou seja, <img src="http://bit.ly/YwMaHD" alt="N_n=1">
quando <img src="http://bit.ly/10afb7o" alt="n=0"> ou <img src="http://bit.ly/14HsgeM" alt="n=1">. Se o
valor de <img src="http://bit.ly/Z4ELdk" alt="n"> for maior que 1, então a função será
invocada recursivamente com os valores <img src="http://bit.ly/18mQyLi" alt="n-2"> e
<img src="http://bit.ly/10fBCrR" alt="n-1"> como argumento, o que resultará num total de
<img src="http://bit.ly/Zxxpzv" alt="1+N_n-2+N_n-1"> invocações. Ou seja, o número de
invocações recursivas da função pode ser expresso também de forma recursiva:</p>
<p><img src="http://bit.ly/125adMb" alt="definição recursiva de N_n"></p>
<p>Esta definição é muito parecida com a definição recursiva da própria sucessão
de Fibonacci. De facto, é fácil demonstrar que <img src="http://bit.ly/10zTgWa" alt="N_n =
2F_n+1-1">. Ou seja, o número de invocações cresce
exponencialmente, tal como a própria sucessão de Fibonacci! Não admira que
esta implementação seja absolutamente inaceitável...</p>
<p>Já agora, podemos também calcular o número de somas realizadas. Seja
<img src="http://bit.ly/13g3vTT" alt="S_n"> o número de somas realizadas quando se invoca
<code>recursive_fibonacci()</code> com o argumento <img src="http://bit.ly/Z4ELdk" alt="n">. É fácil
ver que, quando <img src="http://bit.ly/Z4ELdk" alt="n"> é 0 ou 1, a invocação de
<code>recursive_fibonacci()</code> resulta em 0 somas. Quando se invoca com
<img src="http://bit.ly/Z4ELdk" alt="n"> maior que 1, realiza-se uma soma dos resultados
das invocações recursivas com os valores <img src="http://bit.ly/18mQyLi" alt="n-2"> e
<img src="http://bit.ly/10fBCrR" alt="n-1"> como argumento, o que resultará num total de
<img src="http://bit.ly/YnkQcQ" alt="1+S_n-2+S_n-1"> somas. Ou seja, o número de somas
realizadas durante a invocação da função pode ser expresso também de forma
recursiva:</p>
<p><img src="http://bit.ly/13VO8Ql" alt="definição recursiva de S_n"></p>
<p>Esta definição é também muito parecida com a definição recursiva da própria
sucessão de Fibonacci. De facto, é fácil demonstrar que <img src="http://bit.ly/139Tdpr" alt="S_n =
F_n+1-1">. Ou seja, o número de somas cresce
exponencialmente, tal como a própria sucessão de Fibonacci! Isto quando uma
implementação iterativa trivial precisa de 0 somas para calcular o termo 0 da
sucessão e de <img src="http://bit.ly/10fBCrR" alt="n-1"> somas para calcular o termo
<img src="http://bit.ly/Z4ELdk" alt="n"> quando <img src="http://bit.ly/ZteSVa" alt="n&gt;0">. Mais uma vez,
não admira que esta implementação seja absolutamente inaceitável.</p>
<p>A moral desta estória não é que a recursividade seja naturalmente perversa.
Não o é. As soluções recursivas podem ser tão eficientes quanto as soluções
iterativas. O problema aqui não é a recursividade em si, mas o algoritmo
usado.</p>
<h3>Implementação recursiva com <em>lookup</em></h3>
<h4>Documentação</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fiboncci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term \f$F_{\mathtt{n}}\f$ of the Fibonacci
 * sequence.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the [Fibonacci
 * sequence](http://mathworld.wolfram.com/FibonacciNumber.html), i.e.,
 * \f$F_{\mathtt{n}}\f$. See stupidly_recursive_fibonacci() for further
 * information.
 *
 * This function uses a static array of #MAXIMUM_TERM_FITTING_A_LONG `long`s to
 * store calculated values of the terms of the sequence. After a call to the
 * function with argument \f$n\f$, all future calls to the function with any
 * argument between 0 and \f$n\f$ will execute in constant time. When this
 * doesn't apply, the function will execute in linear time, i.e., \f$O(n)\f$.
 * More precisely, while calculating \f$F_n\f$ by calling
 * `recursive_fibonacci(`\f$n\f$`)`,
 * * the number \f$N(n)\f$ of (recursive) executions of this function is 1 if
 *   \f$n=0\f$ and is \f$2n-1\f$ if \f$n&gt;0\f$;
 * * the number \f$S(n)\f$ of aditions performed is 0 if \f$n=0\f$ and is
 *   \f$n-1\f$ if \f$n&gt;0\f$;
 * * the number \f$T(n)\f$ of array item assignments performed is 1 if \f$n=0\f$
 *   or \f$n=1\f$, and is \f$n+1\f$ if \f$n&gt;1\f$;
 * * the number \f$R(n)\f$ of array item reads performed is 0 if \f$n=0\f$
 *   or \f$n=1\f$, and is \f$n-2\f$ if \f$n&gt;1\f$.
 *
 * These numbers are exact if no other calls to the function have been performed
 * previously, otherwise the values will be either smaller or equal to these. If
 * other calls with an argument larger or equal to \f$n\f$ were performed
 * previously, then \f$N(n)=1\f$, \f$S(n)=0\f$, \f$T(n)=0\f$, and \f$R(n)=1\f$.
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> recursive_fibonacci(<span class="keyword">int</span> n)
{
	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Esta implementação evita os cálculos repetidos dos mesmos termos da
sucessão de Fibonacci usando uma memória auxiliar. A ideia é calcular
cada termo da sucessão uma única vez, guardar o seu valor em memória
e, das próximas vezes que o termo for solicitado, usar o valor
guardado em memória. Isto implica, naturalmente, que a memória usada
persista para além do âmbito restrito de uma execução da função. Ou
seja, não podemos de forma nenhuma usar variáveis locais
<em>automáticas</em>, pois estas são construídas quando a instrução que as
define é executada, e destruídas quando se atinge o final do bloco
onde a sua definição se encontra. Em vez de partir daqui para as
variáveis globais, cujo tempo de vida abarca todo o tempo de execução
do programa, e que são visíveis em todo o programa, preferimos usar
variáveis locais <em>estáticas</em>. Estas variáveis definem-se usando o
<em>qualificador</em> <code>static</code>, duram desde a execução da instrução que as
define até o final do programa e têm a mesma visibilidade restrita
que qualquer variável local tem. Note-se que a instrução de definição
de qualquer variável local estática é executada uma única vez,
nomeadamente a primeira vez que o fluxo de execução do programa passa
por essa instrução. A partir daí a instrução de definição, com a
respectiva inicialização, é ignorada. Logo, a inicialização de uma
variável local estática <em>é feita uma única vez</em> durante a execução do
programa.</p>
<p>Uma vez que o número de termos da sucessão de Fibonacci calculáveis
através desta função é limitado, dado que ela devolve valores <code>long</code>,
só se podendo calcular o valor dos termos entre 0 e
<code>MAXIMUM_TERM_FITTING_A_LONG</code>, podemos reservar espaço para todos os
termos num <em>array</em> <code>F</code> de <code>long</code>. A utilização de uma macro
<code>MAXIMUM_TERM_FITTING_A_LONG</code> na expressão para cálculo do
comprimento do <em>array</em> permite-nos usar inicializadores do C. Dessa
forma, podemos inicializar a memória dos termos da sucessão de
Fibonacci com os dois primeiros termos dessa sucessão, que têm os
valores 0 e 1, respectivamente, correspondentes aos termos com
índices 0 e 1.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">static</span> <span class="keyword">long</span> F[MAXIMUM_TERM_FITTING_A_LONG + <span class="number">1</span>] = {<span class="number">0</span>, <span class="number">1</span>};
</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Não basta definir o espaço de memória dos termos da sucessão: é
necessário definir uma variável que guarde em cada instante quantos
termos estão já calculados. Neste caso inicializa-se a variável com o
valor 2, uma vez que se inicializou a memória com os dois primeiros
termos da sucessão de Fibonacci.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">static</span> <span class="keyword">int</span> number_of_calculated_terms = <span class="number">2</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Estamos agora preparados para indagar o valor do termo da sucessão de
Fibonacci solicitado. Se o termo já constar na memória de termos
calculados, i.e., se o valor <code>n</code> for inferior a
<code>number_of_calculated_terms</code> limitamo-nos a devolver o valor
memorizado.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n &lt; number_of_calculated_terms)
		<span class="keyword">return</span> F[n];

</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>O caso geral passa por</p>
<ol>
<li><p>invocar recursivamente a própria função para obter os termos <code>n -
2</code> e <code>n - 1</code>,</p>
</li>
<li><p>calcular o termo <code>n</code> como soma dos dois termos anteriores
calculados,</p>
</li>
<li><p>guardar esse novo termo na memória, de modo a não precisar de ser
recalculado, e</p>
</li>
<li><p>terminar a função, devolvendo o valor do novo termo ao retornar ao
ponto de invocação da função.</p>
</li>
</ol>
<p>Estes passos estão condensados em apenas duas linhas de código. Essa
condensação seria considerada uma má prática em quase todas as
linguagens de programação, mas este tipo de código é idiomático em C,
pelo que preferimos apresentá-lo desta forma. Seja como for, uma
forma ortodoxa de escrever este código seria:</p>
<pre><code class="lang-C">F[n] = recursive_fibonacci(n - 2) + recursive_fibonacci(n - 1);
number_of_calculated_terms++;

return F[n];</code></pre>
<p>Alternativamente, podemos considerar que o caso especial é aquele em
que o termo pretendido <em>não</em> foi ainda calculado, o que nos levaria
ao seguinte código, bem mais legível, que substitui não apenas as
duas últimas linhas do código apresentado, mas também as duas
anteriores:</p>
<pre><code class="lang-C">if (number_of_calculated_terms &lt;= n) {
        F[n] = recursive_fibonacci(n - 2) +
               recursive_fibonacci(n - 1);
        number_of_calculated_terms++;
}

return F[n];</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>	number_of_calculated_terms++;
	<span class="keyword">return</span> F[n] = recursive_fibonacci(n - <span class="number">2</span>) + recursive_fibonacci(n - <span class="number">1</span>);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h3>Implementação recursiva com <em>lookup</em> usando TAD</h3>
<h4>Documentação</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fiboncci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term \f$F_{\mathtt{n}}\f$ of the Fibonacci
 * sequence.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the [Fibonacci
 * sequence](http://mathworld.wolfram.com/FibonacciNumber.html), i.e.,
 * \f$F_{\mathtt{n}}\f$. See stupidly_recursive_fibonacci() and
 * recursive_fibonacci() for further information.
 *
 * This function uses the ADT `struct sequence_of_longs` store calculated values
 * of the terms of the sequence. After a call to the function with argument
 * \f$n\f$, all future calls to the function with any argument between 0 and
 * \f$n\f$ will execute in constant time. When this doesn't apply, the function
 * will execute in linear time, i.e., \f$O(n)\f$. More precisely, while
 * calculating \f$F_n\f$ by calling `recursive_fibonacci_using_ADT(`\f$n\f$`)`,
 * * the number \f$N(n)\f$ of (recursive) executions of this function is 1 if
 *   \f$n=0\f$ and is \f$2n-1\f$ if \f$n&gt;0\f$;
 * * the number \f$S(n)\f$ of aditions performed is 0 if \f$n=0\f$ and is
 *   \f$n-1\f$ if \f$n&gt;0\f$;
 * * the number \f$T(n)\f$ of additions to the memory of terms is 1 if
 *   \f$n=0\f$ or \f$n=1\f$, and is \f$n+1\f$ if \f$n&gt;1\f$;
 * * the number \f$R(n)\f$ of accesses to the memory of terms is 0 if \f$n=0\f$
 *   or \f$n=1\f$, and is \f$n-2\f$ if \f$n&gt;1\f$.
 *
 * These numbers are exact if no other calls to the function have been performed
 * previously, otherwise the values will be either smaller or equal to these. If
 * other calls with an argument larger or equal to \f$n\f$ were performed
 * previously, then \f$N(n)=1\f$, \f$S(n)=0\f$, \f$T(n)=0\f$, and \f$R(n)=1\f$.
 *
 * Additions of calculated terms to the term memory are less efficient when the
 * ADT `struct sequence_of_longs` is used than when a fixed size array is used.
 * However:
 * * The ADT guarantees that the amortized number of copies of terms perfomed
 *   while adding a new term is always less than 2, approaching 1 as the number
 *   of terms in the sequence grows to infinity.
 * * An ADT such as the one used would be necessary if big integers were used
 *   for the result of this function.
 *
 * See iterative_fibonacci() and tail_recursive_fibonacci() for fast
 * implementations of the Fibonacci sequence that do not require static storage
 * and that execute in linear time.
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> recursive_fibonacci_using_ADT(<span class="keyword">int</span> n)
{
	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Em vez de se usar um <em>array</em> de <code>long</code> como memória para os termos já
calculados da sucessão de Fibonacci, bem como um inteiro indicando a
quantidade de termos memorizados, recorremos aqui ao TAD sucessão de
<code>long</code>, representado pela estrutura <code>struct sequence_of_longs</code>. No
caso particular da sequência se Fibonacci, a utilização deste TAD não
traz grandes vantagens face à utilização de um <em>array</em>, dada a
pequena quantidade de termos da sucessão representáveis no tipo
<em>long</em>. No entanto, é um bom exercício recorrer aqui ao TAD,
exercício que nos pode ser útil noutros casos em que o
dimensionamento <em>a priori</em> do <em>array</em> não seja tão fácil.</p>
<p>Tal como definido o TAD, o código cliente só pode trabalhar com as
sucessões através de ponteiros. Assim, precisamos de definir uma
variável local <em>estática</em> (de modo a que o seu valor persiste entre
invocações da função <code>recursive_fibonacci_using_ADT</code>). Dadas as
restrições do C, não podemos usar o construtor <code>SEQL_new()</code>
directamente na inicialização, que tem de ser feita usando uma
<em>expressão constante</em>. Assim, optámos por inicializar o ponteiro <code>F</code>
com o valor especial <code>NULL</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">static</span> <span class="keyword">struct</span> sequence_of_longs *F = NULL;

</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Dada a inicialização do ponteiro com <code>NULL</code>, podemos agora detectar o
seu valor inicial <code>NULL</code> para lhe atribuir o endereço de uma nova
estrutura <code>struct sequence_of_longs</code> construída de forma dinâmica
através do construtor <code>SEQL_new()</code>. Este código é executado sempre
que a função é invocada, o que é uma infelicidade, mas não há forma
de o evitar, dado que não é possível inicializar o ponteiro <code>F</code> para
a sucessão de <code>long</code> com o valor devolvido pela função <code>SEQL_new()</code>.</p>
<p>Outro problema associado às limitações do C é o da libertação de
memória. O C não fornece nenhum mecanismo para executar código no
contexto das variáveis locais estáticas no final do programa de modo
a podermos «arrumar a casa», ou seja, libertar recursos que lhes
estejam associados. Neste caso os recursos são apenas duas variáveis
dinâmicas: (a) a <code>struct sequence_of_long</code> apontada por <code>F</code> e, embora
como clientes não o devêssemos precisar de o saber, (b) o <em>array</em>
dinâmico usado internamente pelo TAD para guardar os termos. Como
toda a memória dinâmica associada ao programa em execução é libertada
durante a sua terminação, a nossa violação do princípio de que quem
reserva memória explicitamente a deve também libertar explicitamente
não é dramática.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (F == NULL)
		F = SEQL_new();

</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Se o termo já constar na sucessão de <code>long</code> contendo os termos da
sucessão de Fibonacci já calculados, então limitamo-nos a devolvê-lo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n &lt; SEQL_length(F))
		<span class="keyword">return</span> SEQL_term(F, n);

</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Se o termo não está ainda calculado, há que fazê-lo. Uma vez que,
depois de o calcular, teremos de o adicionar à memória e devolver,
definimos uma variável <code>F_n</code> para guardar o valor calculado. Uma vez
que o valor usado para inicializar esta variável depende do valor de
<code>n</code>, usamos o operador <code>?:</code> do C para discriminar entre as três
diferentes formas de inicialização, evitando ter de recorrer a uma
definição sem inicialização seguida de duas instruções de selecção
encadeadas:</p>
<pre><code class="lang-C">long F_n;
if (n == 0)
        F_n = 0L;
else if (n == 1)
        F_n = 1L;
else
        F_n = recursive_fibonacci_using_ADT(n - 2) +
              recursive_fibonacci_using_ADT(n - 1);</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">long</span> F_n = n == <span class="number">0</span> ? <span class="number">0L</span> : n == <span class="number">1</span> ? <span class="number">1L</span> :
		recursive_fibonacci_using_ADT(n - <span class="number">2</span>) +
		recursive_fibonacci_using_ADT(n - <span class="number">1</span>);

</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Agora que já temos o valor de <code>F_n</code> calculado, devemos guardá-lo em
memória, na nossa sucessão de <code>long</code>, de modo a não precisar de ser
calculado de novo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	SEQL_add(F, F_n);

</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Finalmente, devolvemos o valor calculado.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> F_n;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h3>Implementação recursiva eficiente sem memória</h3>
<p>Esta implementação recursiva dispensa a utilização de memória auxiliar e tem
uma eficiência semelhante à da implementação iterativa. No entanto, requer a
definição de uma função auxiliar. Assim, serão definidas duas funções:</p>
<ul>
<li><p><code>tail_recursive_fibonacci()</code> &ndash; Função com ligação (<em>linkage</em>)
externa, i.e., visível em outros ficheiros de implementação que componham o
programa, que tem uma interface idêntica à das restantes funções para cálculo
de termos da sucessão de Fibonacci definidas até agora.</p>
</li>
<li><p><code>tr_fibonacci()</code> &ndash; Função com ligação interna, i.e., invisível
noutros ficheiros de implementação que componham o programa, e que
corresponde à implementação recursiva do cálculo de termos da sucessão de
Fibonacci. A razão para a utilização de um função auxiliar prende-se com o
facto de esta possuir dois parâmetros adicionais, <code>previous_value</code> e
<code>value</code>, que <em>não são relevantes para os clientes do código</em>. Assim, a
função <code>tail_recursive_fibonacci()</code> limitar-se-á a invocar esta função,
passando-lhe os argumentos apropriados, devolvendo o valor que ela por sua
vez devolver.</p>
</li>
</ul>
<h4>Declaração da função auxiliar</h4>
<p>O especificador <code>static</code> usado nesta declaração, e na correspondente
definição que se encontra mais abaixo, tem como objectivo alterar a ligação
desta função de externa (que é a ligação por omissão) para interna.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">static</span> <span class="keyword">long</span> tr_fibonacci(<span class="keyword">int</span> n, <span class="keyword">long</span> previous_value, <span class="keyword">long</span> value);

</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h4>Documentação</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fiboncci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term \f$F_{\mathtt{n}}\f$ of the Fibonacci
 * sequence.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the [Fibonacci
 * sequence](http://mathworld.wolfram.com/FibonacciNumber.html), i.e.,
 * \f$F_{\mathtt{n}}\f$. It is assumed the sequence \f$F_n\f$ starts at
 * \f$n=0\f$, with value 0, followed by value 1, at \f$n=1\f$. That is, the
 * sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 * It can be shown that
 * \f[
 * F_n = \frac{\phi^n-\psi^n}{\sqrt{5}},
 * \f]
 * where \f$\phi=\frac{1+\sqrt{5}}{2}\f$ and \f$\psi=\frac{1-\sqrt{5}}{2}\f$,
 * and also that, even more simple,
 * \f[
 * F_n = \left[\frac{\phi^n}{\sqrt{5}}\right],
 * \f]
 * where \f$[\cdot]\f$ is the nearest integer function.
 *
 * The time taken by the function grows linearly with `n`. More precisely,
 * the number of (recursive) executions of function `tr_fibonacci()` performed
 * while calculating \f$F_n\f$ by calling
 * `tail_recursive_fibonacci(`\f$n\f$`)` is \f$n\f$ and the number
 * of aditions performed is 0 if \f$n=0\f$ and \f$n-1\f$ if \f$n&gt;0\f$.
 *
 * See iterative_fibonacci() for a fast, iterative implementation of the
 * Fibonacci sequence with approximately the same efficiency as this
 * implementation.
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h4>Definição</h4>
<p>A função com ligação externa serve apenas para lidar com o caso especial da
invocação com argumento nulo e para invocar a função auxiliar com os
argumentos apropriados. Estes argumentos correspondem aos valores iniciais da
sucessão de Fibonacci. A função auxiliar usará os parâmetros correspondentes
para ir acumulando os termos da sucessão, como se verá.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> tail_recursive_fibonacci(<span class="keyword">int</span> n)
{
	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Começamos por lidar com o caso especial correspondente ao termo 0 da
sucessão.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n == <span class="number">0</span>)
        	<span class="keyword">return</span> <span class="number">0L</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Finalmente, devolvemos o valor devolvido pela invocação da função
auxiliar <code>tr_fibonacci()</code>, passando-lhe como argumentos o número <code>n</code>
do termo a calcular da sucessão de Fibonacci e os valores dos dois
primeiros termos da sucessão de Fibonacci.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> tr_fibonacci(n, <span class="number">0L</span>, <span class="number">1L</span>);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h4>Definição da função auxiliar</h4>
<p>Esta função calcula de forma recursiva o termo <img src="http://bit.ly/Z4ELdk" alt="n"> da
sucessão de Fibonacci, desde que <img src="http://bit.ly/ZteSVa" alt="n&gt;0">. Para que isso
aconteça, no entanto, a invocação inicial da função deve ser feita não apenas
com o primeiro argumento <img src="http://bit.ly/Z4ELdk" alt="n">, mas também com segundo e
terceiro argumentos 0 e 1, respectivamente, ou seja,
<code>tr_fibonacci</code>(<img src="http://bit.ly/Z4ELdk" alt="n">, 0, 1). Estes argumentos são usados
para inicializar os parâmetros correspondentes, ou seja, <code>n</code>,
<code>previous_value</code> e <code>value</code>. Essa invocação inicial dará origem a outras
invocações recursivas da mesma função, pelo que ocorrerá uma sequência de
execuções da função. Podemos identificar cada uma dessas execuções pelo seu
número de ordem, a que podemos chamar <img src="http://bit.ly/13HLQ6t" alt="k">. A primeira
execução corresponde a <img src="http://bit.ly/12JgpO1" alt="k=1">, a segunda a
<img src="http://bit.ly/11YI327" alt="k=2"> e assim sucessivamente. Iremos demonstrar que,
numa dada execução <img src="http://bit.ly/13HLQ6t" alt="k">, é sempre verdadeira a
seguinte proposição acerca dos valores dos parâmetros da função:</p>
<ul>
<li><p><code>n</code> = <img src="http://bit.ly/196CV28" alt="n+1-k">,</p>
</li>
<li><p><code>previous_value</code> = <img src="http://bit.ly/13EUC6S" alt="F_k-1"> e</p>
</li>
<li><p><code>value</code> = <img src="http://bit.ly/17K5che" alt="F_k">.</p>
</li>
</ul>
<p>A demonstração desta proposição faz-se por indução matemática.</p>
<p>Quando <img src="http://bit.ly/12JgpO1" alt="k=1">, os valores dos parâmetros correspondem
aos argumentos passados na invocação inicial, que por hipótese são
respectivamente <img src="http://bit.ly/Z4ELdk" alt="n">, 0 e 1. Substituindo esses valores
nas igualdades acima e fazendo nelas também <img src="http://bit.ly/12JgpO1" alt="k=1">,
chegamos a</p>
<ul>
<li><p><img src="http://bit.ly/Z4ELdk" alt="n"> = <img src="http://bit.ly/12Jhdm0" alt="n+1-1">, ou seja,
<img src="http://bit.ly/Z4ELdk" alt="n"> = <img src="http://bit.ly/Z4ELdk" alt="n">,</p>
</li>
<li><p>0 = <img src="http://bit.ly/11yBl2I" alt="F_1-1">, ou seja, 0 =
<img src="http://bit.ly/17K5X9W" alt="F_0"> e</p>
</li>
<li><p>1 = <img src="http://bit.ly/11Kux6h" alt="F_1">,</p>
</li>
</ul>
<p>que é obviamente uma proposição verdadeira, dada a definição da sucessão de
Fibonacci.</p>
<p>Seja uma execução <img src="http://bit.ly/13EW0q0" alt="k+1"> resultante da invocação
recursiva da função realizada durante a execução <img src="http://bit.ly/13HLQ6t" alt="k">.
Admitamos que a proposição é verdadeira para <img src="http://bit.ly/13HLQ6t" alt="k">, ou
seja, que</p>
<ul>
<li><p><code>n</code> = <img src="http://bit.ly/196CV28" alt="n+1-k">,</p>
</li>
<li><p><code>previous_value</code> = <img src="http://bit.ly/13EUC6S" alt="F_k-1"> e</p>
</li>
<li><p><code>value</code> = <img src="http://bit.ly/17K5che" alt="F_k">.</p>
</li>
</ul>
<p>Será que também o é para a execução <img src="http://bit.ly/13EW0q0" alt="k+1">? Os
argumentos passados à função na invocação recursiva que ocorre durante a
execução <img src="http://bit.ly/13HLQ6t" alt="k"> da função são, por ordem,</p>
<ul>
<li><p><code>n - 1</code> = <img src="http://bit.ly/175YPW6" alt="n+1-k-1"> =
<img src="http://bit.ly/11cdCdk" alt="n+1-(k+1)">,</p>
</li>
<li><p><code>value</code> = <img src="http://bit.ly/17K5che" alt="F_k"> =
<img src="http://bit.ly/12JiFov" alt="F_(k+1)-1"> e</p>
</li>
<li><p><code>previous_value + value</code> = <img src="http://bit.ly/18CJzjX" alt="F_k-1 + F_k"> =
<img src="http://bit.ly/11iwVhG" alt="F_k+1"> (pela definição da sucessão de Fibonacci).</p>
</li>
</ul>
<p>Conclui-se assim facilmente que, durante a execução
<img src="http://bit.ly/13EW0q0" alt="k+1">, os valores dos parâmetros são</p>
<ul>
<li><p><code>n</code> = <img src="http://bit.ly/11cdCdk" alt="n+1-(k+1)">,</p>
</li>
<li><p><code>previous_value</code> = <img src="http://bit.ly/12JiFov" alt="F_(k+1)-1"> e</p>
</li>
<li><p><code>value</code> = <img src="http://bit.ly/11iwVhG" alt="F_k+1">,</p>
</li>
</ul>
<p>pelo que a proposição também é verdadeira durante a execução
<img src="http://bit.ly/13EW0q0" alt="k+1">.</p>
<p>Também é fácil ver que o número de execuções da função decorrentes da
invocação inicial com argumentos <img src="http://bit.ly/Z4ELdk" alt="n"> (com
<img src="http://bit.ly/ZteSVa" alt="n&gt;0">), 0 e 1 é exactamente
<img src="http://bit.ly/Z4ELdk" alt="n">. Assim, a última execução, durante a qual o caso
especial <code>n == 1</code> é atingido, corresponde a <img src="http://bit.ly/12JjOwh" alt="k=n">, e
por isso o valor devolvido pela instrução <code>return</code> é <code>value</code> =
<img src="http://bit.ly/16jh6vj" alt="F_n">, tal como pretendido. Esse valor é depois
sucessivamente devolvido pelas execuções intermédias da função,
inclusivamente pela invocação inicial. Logo,
<code>tr_fibonacci</code>(<img src="http://bit.ly/Z4ELdk" alt="n">, 0, 1) =
<img src="http://bit.ly/16jh6vj" alt="F_n">.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">static</span> <span class="keyword">long</span> tr_fibonacci(<span class="keyword">int</span> n, <span class="keyword">long</span> previous_value, <span class="keyword">long</span> value)
{
	assert(n &gt;= <span class="number">1</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

	<span class="keyword">if</span> (n == <span class="number">1</span>)
        	<span class="keyword">return</span> value;

	<span class="keyword">return</span> tr_fibonacci(n - <span class="number">1</span>, value, previous_value + value);
}


</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h3>Implementação iterativa</h3>
<h4>Documentação</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fiboncci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term \f$F_{\mathtt{n}}\f$ of the Fibonacci
 * sequence.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the [Fibonacci
 * sequence](http://mathworld.wolfram.com/FibonacciNumber.html), i.e.,
 * \f$F_{\mathtt{n}}\f$. It is assumed the sequence \f$F_n\f$ starts at
 * \f$n=0\f$, with value 0, followed by value 1, at \f$n=1\f$. That is, the
 * sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 * It can be shown that
 * \f[
 * F_n = \frac{\phi^n-\psi^n}{\sqrt{5}},
 * \f]
 * where \f$\phi=\frac{1+\sqrt{5}}{2}\f$ and \f$\psi=\frac{1-\sqrt{5}}{2}\f$,
 * and also that, even more simple,
 * \f[
 * F_n = \left[\frac{\phi^n}{\sqrt{5}}\right],
 * \f]
 * where \f$[\cdot]\f$ is the nearest integer function.
 *
 * The time taken by the function grows linearly with `n`. More precisely,
 * the number of aditions and subtractions performed is 0 if \f$n=0\f$ or
 * \f$n=1\f$, and \f$2(n-2)\f$ if \f$n&gt;1\f$.
 *
 * See tail_recursive_fibonacci() for a fast, tail recursive implementation of
 * the Fibonacci sequence with approximately the same efficiency as this
 * implementation.
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> iterative_fibonacci(<span class="keyword">int</span> n)
{
	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Começamos primeiro por lidar com os casos especiais da sucessão.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n == <span class="number">0</span>)
		<span class="keyword">return</span> <span class="number">0L</span>;
	<span class="keyword">if</span> (n == <span class="number">1</span>)
		<span class="keyword">return</span> <span class="number">1L</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Recorremos a duas variáveis que guardam, em cada passo do ciclo, o
valor do termo anterior e o valor corrente da sucessão.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">long</span> previous_term = <span class="number">1L</span>;
	<span class="keyword">long</span> current_term = <span class="number">1L</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>O ciclo é executado <code>n</code> - 2 vezes, uma vez que os valores iniciais
das variáveis acima correspondem aos termos 1 e 2 da sucessão.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i != n; i++) {
</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>O novo termo corrente, correspondente a <code>i</code> + 1, é obtido
pela soma do termo corrente, correspondente a <code>i</code>, com o
termo anterior, correspondente a <code>i</code> - 1.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		current_term += previous_term;
</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Neste momento temos apenas disponíveis os termos <code>i</code> + 1 e
<code>i</code> - 1. Precisamos de obter o novo termo anterior, ou seja,
o termo <code>i</code>, que perdemos devido à atribuição anterior!
Podemos recuperá-lo obtendo a diferença entre o termo <code>i</code> + 1
e o termo <code>i</code> - 1. Note-se que este truque <em>requer uma
subtracção adicional por cada iteração do ciclo</em>! Podíamos
facilmente evitar essa operação se tivéssemos usado uma
variável auxiliar.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		previous_term = current_term - previous_term;
	}

</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Finalmente, devolvemos o termo corrente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> current_term;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h3>Obtenção de estimativas para o tempo de execução das funções</h3>
<p>Definimos agora um procedimento que realiza experiências para estimar o tempo
de execução de uma qualquer das várias funções de cálculo de termos da
sucessão de Fibonacci que desenvolvemos.</p>

            </div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <h4>Documentação</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Experiments a given Fibonacci sequence term calculation function for
 * a sequence of terms and reports the extimated execution times to `stdout`.
 *
 * \param title The title of the experiment.
 * \param fibonacci Pointer to the function to experiment with.
 * \param last_term_to_test The function will be experimented with terms from 0
 * up to this number.
 * \pre `title` ≠ null
 * \pre `fibonacci` ≠ null
 * \pre `last_term_to_test` ≥ 0
 * \post The results of the experiment are writen in `stdout`.
 *
 * This procedure performs experiments with the provided Fibonacci function
 * `fibonacci()`, reporting the estimated execution times for terms 0 up to
 * `last_term_to_test`. In order to overcome clock resolution issues, each
 * experiment is repeated until a total of at least 0.1 seconds is reached. For
 * all but the first term, the relative increases in execution time are also
 * reported.
 *
 * \bug The minimum accumulated time should not be hardcoded as 0.1 seconds. It
 * should be a parameter of the procedure instead.
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">void</span> experiment_efficiency_of(<span class="keyword">char</span> title[], <span class="keyword">long</span> fibonacci(<span class="keyword">int</span>),
			<span class="keyword">int</span> last_term_to_test)
{
	assert(title != NULL);
	assert(fibonacci != NULL);
	assert(last_term_to_test &gt;= <span class="number">0</span>);

</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Calculamos o número mínimo de <em>clocks</em> do relógio a passar durante as
repetições das execuções da função em teste para perfazer um tempo
mínimo de 0,1 segundos. Dessa forma garantimos um mínimo de precisão
nas medidas sem, com isso, se realizar um número excessivo de
repetições (não queremos esperar muito...). A macro <code>CLOCKS_PER_SEC</code>
representa o número (inteiro) de <em>clocks</em> ou tiques do relógio que
ocorrem num segundo. O tipo <code>clock_t</code> é um sinónimo de um dos tipos
inteiros sem sinal do C (o tipo exacto depende da implementação).</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">const</span> clock_t minimum_accumulated_clocks =
		(clock_t) (<span class="number">0.1</span> * CLOCKS_PER_SEC);

</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Imprimimos o título da experiência em curso.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	printf(<span class="string">"%s\n"</span>, title);

</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>A variável <code>previous_time</code> guardará o tempo de execução estimado da
função para o valor anterior de <code>n</code>. Dessa forma podermos calcular o
aumento percentual do tempo de execução com o aumento em uma unidade
do número do termo da sucessão de Fibonacci em cálculo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">double</span> previous_time = <span class="number">0.0</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Ciclo de repetição de experiências para números crescentes do termo
da sucessão a calcular. Note que os tempos de execução estimados
para as implementações recursivas com memória são afectados por dois
factos: (a) já se calcularam os termos com números inferiores,
que por isso estão memorizados, e (b) após a primeira repetição, o
próprio termo em experiência fica memorizado... Analise os tempos
obtidos tendo estes factos em conta.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n != last_term_to_test + <span class="number">1</span>; n++) {
		<span class="keyword">long</span> f_n;

</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Este primeiro ciclo serve para calcular o número de
repetições necessário para se acumular o tempo mínimo de 0.1
segundos.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		clock_t start = clock();
		<span class="keyword">int</span> repetitions = <span class="number">0</span>;

		<span class="keyword">do</span> {
			f_n = fibonacci(n);
			repetitions++;
		} <span class="keyword">while</span> (clock() &lt; start + minimum_accumulated_clocks);

</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Uma vez que o tempo de execução do ciclo anterior foi
afectado pelo próprio tempo de execução da função <code>clock()</code>,
executamos de novo as repetições para obtermos as estimativas
do tempo de execução da função de cálculo da sucessão de
Fibonacci excluindo o tempo de execução da função <code>clock()</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		start = clock();

		<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != repetitions; r++)
			f_n = fibonacci(n);

		clock_t end = clock();

</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Estimamos o tempo de execução da função de cálculo da
sucessão de Fibonacci dividindo o tempo total de execução do
ciclo pelo seu número de iterações (<code>repetitions</code>). O tempo
de execução do ciclo em segundos é calculado dividindo o
número total de <em>clocks</em> ou tiques do relógio decorridos
entre o início e o fim do ciclo pelo número de tiques por
segundo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">double</span> time =
			(<span class="keyword">double</span>) (end - start) / CLOCKS_PER_SEC / repetitions;

</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Imprimimos o valor do termo da sucessão calculado bem como a
estimativa do tempo necessário para efectuar esse cálculo. Se
não se tratar do primeiro termo da sucessão, imprimimos
também a variação percentual desse tempo face ao necessário
para o cálculo do termo anterior.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		<span class="keyword">if</span> (previous_time == <span class="number">0.0</span>)
			printf(<span class="string">"F(%d) = %ld in %g s\n"</span>, n, f_n, time);
		<span class="keyword">else</span>
			printf(<span class="string">"F(%d) = %ld in %.3g seconds, %+.1f%%\n"</span>, n, f_n,
				time, time / previous_time * <span class="number">100.0</span> - <span class="number">100.0</span>);

</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Guardamos o tempo estimado como tempo anterior a usar na
próxima iteração do ciclo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>		previous_time = time;
	}
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <h3>Programa principal</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> main(<span class="keyword">void</span>)
{
</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Definimos uma constante que guarda o número do maior termo da
sucessão de Fibonacci que será usado nas experiências realizadas com
a função que usa o algoritmo recursivo estúpido. Sem este cuidado, o
nosso programa não terminaria em tempo útil.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">const</span> <span class="keyword">int</span> last_term_to_test_with_stupid_algorithm = <span class="number">42</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Realizamos experiências com cada uma das funções, para obter
estimativas do seu tempo de execução.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	experiment_efficiency_of(
		<span class="string">"Stupidly recursive implementation of the fibonacci sequence:"</span>,
		stupidly_recursive_fibonacci,
		last_term_to_test_with_stupid_algorithm);
	experiment_efficiency_of(
		<span class="string">"Recursive implementation of the fibonacci sequence using array"</span>
		<span class="string">" for storage:"</span>,
		recursive_fibonacci, MAXIMUM_TERM_FITTING_A_LONG);
	experiment_efficiency_of(
		<span class="string">"Recursive implementation of the fibonacci sequence using ADT"</span>
		<span class="string">" for storage:"</span>,
		recursive_fibonacci_using_ADT, MAXIMUM_TERM_FITTING_A_LONG);
	experiment_efficiency_of(
		<span class="string">"Tail recursive implementation of the fibonacci sequence:"</span>,
		iterative_fibonacci, MAXIMUM_TERM_FITTING_A_LONG);
	experiment_efficiency_of(
		<span class="string">"Two variable iterative implementation of the fibonacci"</span>
		<span class="string">" sequence:"</span>,
		iterative_fibonacci, MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Finalmente, usamos cada uma das funções para obter os termos da
sucessão, podendo assim mais facilmente confirmar que os cálculos
estão a ser realizados correctamente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n != MAXIMUM_TERM_FITTING_A_LONG + <span class="number">1</span>; n++) {
		<span class="keyword">if</span> (n &lt;= last_term_to_test_with_stupid_algorithm)
			printf(<span class="string">"F(%d) [stupidly recursive] = %ld\n"</span>,
				n, stupidly_recursive_fibonacci(n));
		printf(<span class="string">"F(%d) [recursive         ] = %ld\n"</span>,
			n, recursive_fibonacci(n));
		printf(<span class="string">"F(%d) [recursive with ADT] = %ld\n"</span>,
			n, recursive_fibonacci_using_ADT(n));
		printf(<span class="string">"F(%d) [tail recursive    ] = %ld\n"</span>,
			n, tail_recursive_fibonacci(n));
		printf(<span class="string">"F(%d) [iterative         ] = %ld\n"</span>,
			n, iterative_fibonacci(n));
		putchar(<span class="string">'\n'</span>);
	}

	<span class="keyword">return</span> EXIT_SUCCESS;
}

</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
