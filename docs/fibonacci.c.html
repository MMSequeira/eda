<!DOCTYPE html>

<html>
<head>
  <title>`fibonacci.c`</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script src="http://softwaremaniacs.org/media/soft/highlight/highlight.pack.js"></script>
  <script>
    hljs.tabReplace = '        ';
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="array_utils.h.html">
                array_utils.h
              </a>
            
              
              <a class="source" href="print.c.html">
                print.c
              </a>
            
              
              <a class="source" href="arrays_and_pointers.c.html">
                arrays_and_pointers.c
              </a>
            
              
              <a class="source" href="arrays_basics.c.html">
                arrays_basics.c
              </a>
            
              
              <a class="source" href="fibonacci.c.html">
                fibonacci.c
              </a>
            
              
              <a class="source" href="hello_world.c.html">
                hello_world.c
              </a>
            
              
              <a class="source" href="hello_world_correct.c.html">
                hello_world_correct.c
              </a>
            
              
              <a class="source" href="malloc_stuff.c.html">
                malloc_stuff.c
              </a>
            
              
              <a class="source" href="nans_and_other_oddities.c.html">
                nans_and_other_oddities.c
              </a>
            
              
              <a class="source" href="rationals_with_structs.c.html">
                rationals_with_structs.c
              </a>
            
              
              <a class="source" href="routine_pointers.c.html">
                routine_pointers.c
              </a>
            
              
              <a class="source" href="experiments.c.html">
                experiments.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.c.html">
                naive_sequence_of_longs.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.h.html">
                naive_sequence_of_longs.h
              </a>
            
              
              <a class="source" href="sequence_of_longs.c.html">
                sequence_of_longs.c
              </a>
            
              
              <a class="source" href="sequence_of_longs.h.html">
                sequence_of_longs.h
              </a>
            
              
              <a class="source" href="tests.c.html">
                tests.c
              </a>
            
              
              <a class="source" href="sizeof_and_arrays.c.html">
                sizeof_and_arrays.c
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1><code>fibonacci.c</code></h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/**
 * \file fibonacci.c
 * \brief Illustrates possible implementations of the calculation of terms of
 * the Fibonacci sequence.
 *
 * Iterative and recursive implementations of the calculation of terms of
 * the Fibonacci sequence. These implementations are used to illustrate
 * iteration vs. recursion, and also to show how a naïve implementation of
 * recursion may lead to serious problems.
 */</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2>Coelhos, recursão e iteração</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Ofereceram ao Sr. Fibonacci um casal de coelhos, recém-nascidos, de um
espécie curiosa: tornam-se férteis ao fim de um mês de vida, concebem logo
que possível, têm uma gestação de exactamente um mês, cada ninhada consiste
sempre num casalinho de coelhos. Nunca morrem. O Sr. Fibonacci preocupou-se:
teria comida que chegue para os coelhos? Pôs-se a calcular a evolução do
número de casais de coelhos ao longo do tempo:</p>
<ol>
<li><p>No mês zero o Sr. Fibonacci vivia feliz, sem qualquer coelho. Mal
calculava o seu destino...</p>
</li>
<li><p>No primeiro mês há um casal de coelhos inférteis.</p>
</li>
<li><p>No segundo mês há um casal de coelhos, já férteis e, claro está, com a
coelha no início da gestação de mais um casalinho.</p>
</li>
<li><p>No terceiro mês há o casal de coelhos original, fértil, e já no início da
gestação de mais um casalinho de coelhos. E há, claro está, um casal recém-
nascido e, por isso, infértil. Ou seja, há dois casais de coelhos, um fértil
e outro infértil.</p>
</li>
<li><p>No quarto mês há os dois casais do mês anterior, já férteis, adicionados
de um casal recém-nascido, resultado do acasalamento do único casal fértil do
mês anterior. Ou seja, há três casais de coelhos, dois férteis e um infértil.</p>
</li>
<li><p>No quinto mês há os três casais do mês anterior, já férteis, adicionados
de dois casais recém-nascidos, resultado do acasalamento entre os dois casais
férteis do mês anterior. Ou seja, há cinco casais de coelhos, três férteis e
dois inférteis.</p>
</li>
</ol>
<p>O Sr. Fibonacci concluiu rapidamente que, a partir do terceiro mês,</p>
<ul>
<li><p>o número de casais férteis num mês é sempre igual ao número total de casais
no mês anterior e</p>
</li>
<li><p>o número total de casais num mês é sempre igual à soma do número total de
casais existente no mês anterior com o número de casais recém-nascidos, que
é igual ao número de casais férteis no mês anterior e que, por isso, é
igual ao número total de casais existentes dois meses antes.</p>
</li>
</ul>
<p>Sendo <img src="http://bit.ly/ZCdcqY" alt="F(n)"> o número de casais de coelhos no mês
<img src="http://bit.ly/Z4ELdk" alt="n">, então, desde que <img src="http://bit.ly/10vWeOB" alt="n&gt;2">,
<img src="http://bit.ly/10zLPR3" alt="F(n)=F(n-2)+F(n-1)">. Quando
<img src="http://bit.ly/14HsgeM" alt="n=1"> ou <img src="http://bit.ly/YVICg2" alt="n=2">,
<img src="http://bit.ly/13V3GYG" alt="F(n)=1">. Ou seja, esta sucessão pode ser descrita de
forma <em>recursiva</em>, ou seja, definindo os termos da sucessão em função de
outros termos da mesma sucessão.</p>
<p>O que pretendemos aqui é implementar uma função que receba o mês como
argumento e devolva o número de casais existentes nesse mês. Como não
fornecemos apenas uma implementação, mas várias, com diferentes eficiências,
os nomes dessas funções não poderão ser simplesmente <code>fibonacci()</code>, incluindo
no seu nome um sufixo que identifica o tipo de implementação usado. Pode
argumentar-se que, sendo a eficiência parte da interface de um módulo, então
é razoável usar esses sufixos. No entanto, seria preferível, se o nosso
objectivo não fosse o estudo dos algoritmos em si, mas a criação de
ferramentas para utilização futura ou para disponibilização a terceiros, usar
sufixos que fossem reveladores da eficiência da função, e não da sua
implementação.</p>
<p>Antes, porém, de passar às implementações, é preciso dizer que o presente
oferecido ao Sr. Fibonacci está realmente envenenado. Com efeito, a sucessão
de Fibonacci cresce de forma extremamente rápida. Assim, no mês 120, ou seja,
dez anos depois da oferta do casal original, o número de casais a alimentar é
exactamente 5&thinsp;358&thinsp;359&thinsp;254&thinsp;990&thinsp;966&thinsp;640&thinsp;871&thinsp;840.
Este valor é demasiado grande para os <code>int</code> nas nossas máquinas habituais,
que têm 32 <em>bits</em>, ou mesmo para os <em>long</em>, com 64 <em>bits</em> nessas mesmas
máquinas. Por outro lado, a precisão limitada dos tipos de virgula flutuante
pode pôr problemas complicados ao cálculo dos termos da sucessão (já
tínhamos dito que dos tipos de vírgula flutuante se foge como diabo da
cruz?). O código abaixo recorre ao tipo <code>long</code>, numa tentativa de evitar que
se atinjam muito cedo os limites dos inteiros. É uma má solução, no entanto.
Uma boa solução passaria pela utilização de um tipo capaz de representar
números inteiros de dimensão arbitrária (desde que haja memória para o
guardar, bem entendido). A implementação de um tal tipo é um excelente
exercício de algoritmos e estruturas de dados, mas não o resolveremos aqui.</p>
<h2>Implementação</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Como se referiu, usamos <code>long</code> como tipo de devolução das funções de cálculo
dos termos da sucessão de Fibonacci. Será que isso adianta muito, em relação
à utilização de <em>int</em>? Fazendo algumas experiências, é fácil verificar que,
em máquinas em que os <code>int</code> têm 32 <em>bits</em>, ou seja, em máquinas em que o
maior valor representável num <code>int</code> é 2&thinsp;147&thinsp;483&thinsp;647, o
maior termo da sucessão de Fibonacci representável num <code>int</code> é o termo 46, ou
seja, <img src="http://bit.ly/XgffV7" alt="F(46)">, cujo valor é
1&thinsp;836&thinsp;311&thinsp;903. Isto é, usando <code>int</code> só conseguimos obter
valores correctos para os primeiros 47 termos da sucessão. Usando <code>long</code>, é
fácil verificar que, em máquinas em que os <code>long</code> têm 64 <em>bits</em>, ou seja, em
máquinas em que o maior valor representável num <code>long</code> é
9&thinsp;223&thinsp;372&thinsp;036&thinsp;854&thinsp;775&thinsp;807, o maior
termo da sucessão de Fibonacci representável num <code>long</code> é o termo 92, ou
seja, <img src="http://bit.ly/12kthcr" alt="F(92)">, cujo valor é
7&thinsp;540&thinsp;113&thinsp;804&thinsp;746&thinsp;346&thinsp;429. Isto é,
usando <code>long</code> só conseguimos obter valores correctos para os primeiros 93
termos da sucessão. Melhor que os 47 se se usasse <code>int</code>, mas ainda assim um
valor bem pequeno.</p>
<p>O maior termo calculável usando <code>long</code>, 92, deve ser usado nas pré-condições
das funções abaixo. Usar o valor literal nesse código é muito má ideia, pois
torna mais difícil a compreensão do código. Afinal, haverá que perceba
imediatamente o significado desse valor? Para resolver o problema definimos
uma constante para guardar esse valor. Uma vez que esta constante será usada
para dimensionar <em>arrays</em> que pretendemos inicializar usando as usuais listas
de inicializadores do C, não podemos usar a forma mais óbvia de definir
constantes em C, i.e., não podemos usar</p>
<pre><code class="lang-C">const int maximum_term_fitting_a_long = 92;</code></pre>
<p>tendo, pelo contrário de usar uma macro do pré-processador.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#define MAXIMUM_TERM_FITTING_A_LONG 92</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3>Inclusão de ficheiros de cabeçalho</h3>
<p>Incluímos os seguintes ficheiros de cabeçalho:</p>
<ul>
<li><p><code>stdio.h</code> &ndash; Para declaração do procedimento <code>printf()</code>.</p>
</li>
<li><p><code>stdlib.h</code> &ndash; Para definição da <em>macro</em> <code>EXIT_SUCCESS</code>.</p>
</li>
<li><p><code>time.h</code> &ndash; Para definição da função <code>clock()</code> e da macro
<code>CLOCKS_PER_SEC</code>.</p>
</li>
<li><p><code>assert.h</code> &ndash; Para definição da macro <code>assert()</code>.</p>
</li>
</ul>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;assert.h&gt;</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h3>Inclusão de ficheiros de cabeçalho próprios</h3>
<p>Incluímos apenas um ficheiro de cabeçalho «não oficial»:</p>
<ul>
<li><code>sequence_of_longs.h</code> &ndash; Para declaração do TAD sucessão de <code>long</code>
usada para guardar em memória dos termos da sucessão já calculados.</li>
</ul>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include "sequence_of_longs.h"</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h3>Implementação recursiva «estúpida»</h3>
<h4>Documentação</h4>
<p>A documentação da função é feita no formato do
<a href="http://doxygen.org/">Doxygen</a>, como habitualmente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fiboncci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term of the Fibonacci sequence. The time taken
 * by the function grows exponentially with `n`.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the Fibonacci sequence. It is assumed the sequence
 * starts at `n` = 0, with value 0, followed by value 1, at `n` = 1. That is,
 * the sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h4>Definição</h4>
<p>Esta implementação segue a estratégia mais comum das soluções recursivas:
decompor o problema em problemas mais simples, resolver esses problemas mais
simples usando exactamente a mesma estratégia, recursivamente, e compor as
soluções dos subproblemas de modo a obter a solução do problema como um todo.
Uma solução recursiva, como esta, precisa de possuir casos de paragem (ou
casos especiais), para os quais a solução é imediata, não sendo necessária
qualquer decomposição adicional. A definição recursiva da sucessão de
Fibonacci aparenta adequar-se bem a esta estratégia:</p>
<p><img src="http://bit.ly/13TPIpP" alt="F(n)={0, se n = 0, 1, se n = 1, e F(n-2) + F(n-1), se n &gt; 
1}"></p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> stupidly_recursive_fibonacci(<span class="keyword">int</span> n)
{
</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Em primeiro lugar, verificamos as pré-condições e lidamos com as
violações que forem detectadas.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Depois, lidamos com os dois casos especiais da sucessão. Estes casos
servem também para garantir que as invocações recursivas desta função
acabarão sempre por terminar (em tempo finito).</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n == <span class="number">0</span>)
		<span class="keyword">return</span> <span class="number">0L</span>;
	<span class="keyword">if</span> (n == <span class="number">1</span>)
		<span class="keyword">return</span> <span class="number">1L</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>O caso geral é simplesmente a devolução da soma dos termos anterior
da sucessão. Para os obter, invocamos a própria função com os dois
valores inteiros anteriores a <code>n</code>. O problema desta implenentação é
que se está a reduzir o problema de calcular
<img src="http://bit.ly/ZCdcqY" alt="F(n)"> aos subproblemas de calcular
<img src="http://bit.ly/14HrTAK" alt="F(n-2)"> e de calcular
<img src="http://bit.ly/13V2Vid" alt="F(n-1)">, <em>mas estes subproblemas não são
independentes!</em></p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> stupidly_recursive_fibonacci(n - <span class="number">2</span>)
		+ stupidly_recursive_fibonacci(n - <span class="number">1</span>);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h3>Implementação recursiva com <em>lookup</em></h3>
<h4>Documentação</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fibonacci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term of the Fibonacci sequence. The time taken
 * by the function grows !!!!!!!!!!!!!!!!!!!! with `n`.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the Fibonacci sequence. It is assumed the sequence
 * starts at `n` = 0, with value 0, followed by value 1, at `n` = 1. That is,
 * the sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> recursive_fibonacci(<span class="keyword">int</span> n)
{
	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Esta implementação evita os cálculos repetidos dos mesmos termos da
sucessão de Fibonacci usando uma memória auxiliar. A ideia é calcular
cada termo da sucessão uma única vez, guardar o seu valor em memória
e, das próximas vezes que o termo for solicitado, usar o valor
guardado em memória. Isto implica, naturalmente, que a memória usada
persista para além do âmbito restrito de uma execução da função. Ou
seja, não podemos de forma nenhuma usar variáveis locais
<em>automáticas</em>, pois estas são construídas quando a instrução que as
define é executada, e destruídas quando se atinge o final do bloco
onde a sua definição se encontra. Em vez de partir daqui as variáveis
globais, cujo tempo de vida abarca todo o tempo de execução do
programa, e que são visíveis em todo o programa, preferimos usar
variáveis locais <em>estáticas</em>. Estas variáveis definem-se usando o
<em>qualificador</em> <code>static</code>, duram desde a execução da instrução que as
define até o final do programa e têm a mesma visibilidade restrita
que qualquer variável local tem. Note-se que a instrução de definição
de qualquer variável local estática é executada uma única vez,
nomeadamente a primeira vez que o fluxo de execução do programa passa
por essa instrução. A partir daí a instrução de definição, com a
respectiva inicialização, é ignorada. Logo, a inicialização de uma
variável local estática <em>é feita uma única vez</em> durante a execução do
programa.</p>
<p>Uma vez que o número de termos da sucessão de Fibonacci calculáveis
através desta função é limitado, dado que ela devolve valores <code>long</code>,
só se podendo calcular o valor dos termos entre 0 e
<code>MAXIMUM_TERM_FITTING_A_LONG</code>, podemos reservar espaço para todos os
termos num <em>array</em> <code>F</code> de <code>long</code>. A utilização de uma macro
<code>MAXIMUM_TERM_FITTING_A_LONG</code> na expressão para cálculo do
comprimento do <em>array</em> permite-nos usar inicializadores do C. Dessa
forma, podemos inicializar a memória dos termos da sucessão de
Fibonacci com os dois primeiros termos dessa sucessão, que têm os
valores 0 e 1, respectivamente, correspondentes aos termos com
índices 0 e 1.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">static</span> <span class="keyword">long</span> F[MAXIMUM_TERM_FITTING_A_LONG + <span class="number">1</span>] = {<span class="number">0</span>, <span class="number">1</span>};
</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Não basta definir o espaço de memória dos termos da sucessão: é
necessário definir uma variável que guarde em cada instante quantos
termos estão já calculados. Neste caso inicializa-se a variável com o
valor 2, uma vez que se inicializou a memória com os dois primeiros
termos da sucessão de Fibonacci.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">static</span> <span class="keyword">int</span> number_of_calculated_terms = <span class="number">2</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Estamos agora preparados para indagar o valor do termo da sucessão de
Fibonacci solicitado. Se o termo já constar na memória de termos
calculados, i.e., se o valor <code>n</code> for inferior a
<code>number_of_calculated_terms</code> limitamo-nos a devolver o valor
memorizado.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n &lt; number_of_calculated_terms)
		<span class="keyword">return</span> F[n];

</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>O caso geral passa por</p>
<ol>
<li><p>invocar recursivamente a própria função para obter os termos <code>n -
2</code> e <code>n - 1</code>,</p>
</li>
<li><p>calcular o termo <code>n</code> como soma dos dois termos anteriores
calculados,</p>
</li>
<li><p>guardar esse novo termo na memória, de modo a não precisar de ser
recalculado, e</p>
</li>
<li><p>terminar a função, devolvendo o valor do novo termo ao retornar ao
ponto de invocação da função.</p>
</li>
</ol>
<p>Estes passos estão condensados em apenas duas linhas de código. Essa
condensação seria considerada uma má prática em quase todas as
linguagens de programação, mas este tipo de código é idiomático em C,
pelo que preferimos apresentá-lo desta forma. Seja como for, uma
forma ortodoxa de escrever este código seria:</p>
<pre><code class="lang-C">F[n] = recursive_fibonacci(n - 2) + recursive_fibonacci(n - 1);
number_of_calculated_terms++;

return F[n];</code></pre>
<p>Alternativamente, podemos considerar que o caso especial é aquele em
que o termo pretendido <em>não</em> foi ainda calculado, o que nos levaria
ao seguinte código, bem mais legível, que substitui não apenas as
duas últimas linhas do código apresentado, mas também as duas
anteriores:</p>
<pre><code class="lang-C">if (number_of_calculated_terms &lt;= n) {
        F[n] = recursive_fibonacci(n - 2) + 
               recursive_fibonacci(n - 1);
        number_of_calculated_terms++;
}

return F[n];</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>	number_of_calculated_terms++;
	<span class="keyword">return</span> F[n] = recursive_fibonacci(n - <span class="number">2</span>) + recursive_fibonacci(n - <span class="number">1</span>);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h3>Implementação recursiva com <em>lookup</em> usando TAD</h3>
<h4>Documentação</h4>
<p>A documentação da função é feita no formato do
<a href="http://doxygen.org/">Doxygen</a>, como habitualmente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fibonacci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term of the Fibonacci sequence. The time taken
 * by the function grows !!!!!!!!!!!!!!!!!!!! with `n`.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the Fibonacci sequence. It is assumed the sequence
 * starts at `n` = 0, with value 0, followed by value 1, at `n` = 1. That is,
 * the sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> recursive_fibonacci_using_ADT(<span class="keyword">int</span> n)
{
</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Em primeiro lugar, verificamos as pré-condições e lidamos com as
violações que forem detectadas.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>!!!!!!!!!!!! Inicialização e static. Casos especiais.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">static</span> <span class="keyword">struct</span> sequence_of_longs *F = NULL;

	<span class="keyword">if</span> (F == NULL)
		F = SEQL_new();

</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Se o termo já constar na memória de termos calculados, limitamo-nos
a devolvê-lo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n &lt; SEQL_length(F))
		<span class="keyword">return</span> SEQL_term(F, n);

	<span class="keyword">long</span> F_n;
	<span class="keyword">if</span> (n == <span class="number">0</span>)
		F_n = <span class="number">0L</span>;
	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)
		F_n = <span class="number">1L</span>;
	<span class="keyword">else</span>
		F_n = recursive_fibonacci_using_ADT(n - <span class="number">2</span>) + 
			recursive_fibonacci_using_ADT(n - <span class="number">1</span>);

	SEQL_add(F, F_n);
	<span class="keyword">return</span> F_n;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h3>Implementação iterativa</h3>
<h4>Documentação</h4>
<p>A documentação da função é feita no formato do
<a href="http://doxygen.org/">Doxygen</a>, como habitualmente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fiboncci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term of the Fibonacci sequence. The time taken
 * by the function grows linearly with `n`.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the Fibonacci sequence. It is assumed the sequence
 * starts at `n` = 0, with value 0, followed by value 1, at `n` = 1. That is,
 * the sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> iterative_fibonacci(<span class="keyword">int</span> n)
{
	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

	<span class="keyword">if</span> (n == <span class="number">0</span>)
		<span class="keyword">return</span> <span class="number">0L</span>;
	<span class="keyword">if</span> (n == <span class="number">1</span>)
		<span class="keyword">return</span> <span class="number">1L</span>;

	<span class="keyword">long</span> previous_term = <span class="number">1L</span>;
	<span class="keyword">long</span> current_term = <span class="number">1L</span>;
	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i != n; i++) {
		current_term += previous_term;
		previous_term = current_term - previous_term;
	}

	<span class="keyword">return</span> current_term;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h3>Procedimento !!!!!!!</h3>
<h4>Documentação</h4>
<p>!!!!!!!!</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief !!!!!!!!!!!! (includes month 0)
 *
 * \param n !!!!!!!!!
 * \return !!!!!!!!!!!
 * \pre `n` ≥ 0
 * \post !!!
 *
 * !!!!!!!!!!!!!!!
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">void</span> experiment_efficiency_of(<span class="keyword">char</span> title[], <span class="keyword">long</span> fibonacci(<span class="keyword">int</span>),
			<span class="keyword">int</span> last_term)
{
	printf(<span class="string">"%s\n"</span>, title);
	<span class="keyword">double</span> previous_time = <span class="number">0.0</span>;
	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n != last_term + <span class="number">1</span>; n++) {
		clock_t start = clock();
		<span class="keyword">int</span> f = fibonacci(n);
		clock_t end = clock();
		<span class="keyword">double</span> time = (<span class="keyword">double</span>) (end - start) / CLOCKS_PER_SEC;
		printf(<span class="string">"f(%d) = %d in %.4fs %g\n"</span>, n, f, time,
			time / previous_time);
		previous_time = time;
	}
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h3>Procedimento !!!!!!!</h3>
<p>!!!!!!!!</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> main(<span class="keyword">void</span>)
{
	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n != MAXIMUM_TERM_FITTING_A_LONG + <span class="number">1</span>; n++) {
</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <pre><code>printf(&quot;F(%d) [stupid recursive] = %ld\n&quot;, n, stupidly_recursive_fibonacci(n));</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>		printf(<span class="string">"F(%d) [recursive         ] = %ld\n"</span>, n, recursive_fibonacci(n));
		printf(<span class="string">"F(%d) [recursive with ADT] = %ld\n"</span>, n, recursive_fibonacci_using_ADT(n));
		printf(<span class="string">"F(%d) [iterative         ] = %ld\n"</span>, n, iterative_fibonacci(n));
		putchar(<span class="string">'\n'</span>);
	}

	experiment_efficiency_of(<span class="string">"Stupidly recursive implementation of the fibonacci sequence:"</span>,
				stupidly_recursive_fibonacci, <span class="number">35</span>);
	experiment_efficiency_of(<span class="string">"Recursive implementation of the fibonacci sequence:"</span>,
				recursive_fibonacci, <span class="number">35</span>);
	experiment_efficiency_of(<span class="string">"Recursive implementation of the fibonacci sequence using ADT for storage:"</span>,
				recursive_fibonacci_using_ADT, <span class="number">35</span>);
	experiment_efficiency_of(<span class="string">"Three variable iterative implementation of the fibonacci sequence:"</span>,
				iterative_fibonacci, <span class="number">35</span>);

	<span class="keyword">return</span> EXIT_SUCCESS;
}

</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
