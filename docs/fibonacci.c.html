<!DOCTYPE html>

<html>
<head>
  <title>`fibonacci.c`</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script src="http://softwaremaniacs.org/media/soft/highlight/highlight.pack.js"></script>
  <script>
    hljs.tabReplace = '        ';
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="array_utils.h.html">
                array_utils.h
              </a>
            
              
              <a class="source" href="print.c.html">
                print.c
              </a>
            
              
              <a class="source" href="arrays_and_pointers.c.html">
                arrays_and_pointers.c
              </a>
            
              
              <a class="source" href="arrays_basics.c.html">
                arrays_basics.c
              </a>
            
              
              <a class="source" href="fibonacci.c.html">
                fibonacci.c
              </a>
            
              
              <a class="source" href="hello_world.c.html">
                hello_world.c
              </a>
            
              
              <a class="source" href="hello_world_correct.c.html">
                hello_world_correct.c
              </a>
            
              
              <a class="source" href="malloc_stuff.c.html">
                malloc_stuff.c
              </a>
            
              
              <a class="source" href="nans_and_other_oddities.c.html">
                nans_and_other_oddities.c
              </a>
            
              
              <a class="source" href="rationals_with_structs.c.html">
                rationals_with_structs.c
              </a>
            
              
              <a class="source" href="routine_pointers.c.html">
                routine_pointers.c
              </a>
            
              
              <a class="source" href="experiments.c.html">
                experiments.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.c.html">
                naive_sequence_of_longs.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.h.html">
                naive_sequence_of_longs.h
              </a>
            
              
              <a class="source" href="sequence_of_longs.c.html">
                sequence_of_longs.c
              </a>
            
              
              <a class="source" href="sequence_of_longs.h.html">
                sequence_of_longs.h
              </a>
            
              
              <a class="source" href="tests.c.html">
                tests.c
              </a>
            
              
              <a class="source" href="sizeof_and_arrays.c.html">
                sizeof_and_arrays.c
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1><code>fibonacci.c</code></h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/**
 * \file fibonacci.c
 * \brief Illustrates possible implementations of the calculation of terms of
 * the Fibonacci sequence.
 *
 * Iterative and recursive implementations of the calculation of terms of
 * the Fibonacci sequence. These implementations are used to illustrate
 * iteration vs. recursion, and also to show how a naïve implementation of
 * recursion may lead to serious problems.
 */</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2>Coelhos, recursão e iteração</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Ofereceram ao Sr. Fibonacci um casal de coelhos, recém-nascidos, de um
espécie curiosa: tornam-se férteis ao fim de um mês de vida, concebem logo
que possível, têm uma gestação de exactamente um mês, cada ninhada consiste
sempre num casalinho de coelhos. Nunca morrem. O Sr. Fibonacci preocupou-se:
teria comida que chegue para os coelhos? Pôs-se a calcular a evolução do
número de casais de coelhos ao longo do tempo:</p>
<ol>
<li><p>No mês zero o Sr. Fibonacci vivia feliz, sem qualquer coelho. Mal
calculava o seu destino...</p>
</li>
<li><p>No primeiro mês há um casal de coelhos inférteis.</p>
</li>
<li><p>No segundo mês há um casal de coelhos, já férteis e, claro está, com a
coelha no início da gestação de mais um casalinho.</p>
</li>
<li><p>No terceiro mês há o casal de coelhos original, fértil, e já no início da
gestação de mais um casalinho de coelhos. E há, claro está, um casal recém-
nascido e, por isso, infértil. Ou seja, há dois casais de coelhos, um fértil
e outro infértil.</p>
</li>
<li><p>No quarto mês há os dois casais do mês anterior, já férteis, adicionados
de um casal recém-nascido, resultado do acasalamento do único casal fértil do
mês anterior. Ou seja, há três casais de coelhos, dois férteis e um infértil.</p>
</li>
<li><p>No quinto mês há os três casais do mês anterior, já férteis, adicionados
de dois casais recém-nascidos, resultado do acasalamento entre os dois casais
férteis do mês anterior. Ou seja, há cinco casais de coelhos, três férteis e
dois inférteis.</p>
</li>
</ol>
<p>O Sr. Fibonacci concluiu rapidamente que, a partir do terceiro mês,</p>
<ul>
<li><p>o número de casais férteis num mês é sempre igual ao número total de casais
no mês anterior e</p>
</li>
<li><p>o número total de casais num mês é sempre igual à soma do número total de
casais existente no mês anterior com o número de casais recém-nascidos, que
é igual ao número de casais férteis no mês anterior e que, por isso, é
igual ao número total de casais existentes dois meses antes.</p>
</li>
</ul>
<p>Sendo <img src="http://bit.ly/ZCdcqY" alt="F(n)"> o número de casais de coelhos no mês
<img src="http://bit.ly/Z4ELdk" alt="n">, então, desde que <img src="http://bit.ly/10vWeOB" alt="n&gt;2">,
<img src="http://bit.ly/10zLPR3" alt="F(n)=F(n-2)+F(n-1)">. Quando
<img src="http://bit.ly/14HsgeM" alt="n=1"> ou <img src="http://bit.ly/YVICg2" alt="n=2">,
<img src="http://bit.ly/13V3GYG" alt="F(n)=1">. Ou seja, esta sucessão pode ser descrita de
forma <em>recursiva</em>, ou seja, definindo os termos da sucessão em função de
outros termos da mesma sucessão.</p>
<p>O que pretendemos aqui é implementar uma função que receba o mês como
argumento e devolva o número de casais existentes nesse mês. Como não
fornecemos apenas uma implementação, mas várias, com diferentes eficiências,
os nomes dessas funções não poderão ser simplesmente <code>fibonacci()</code>, incluindo
no seu nome um sufixo que identifica o tipo de implementação usado. Pode
argumentar-se que, sendo a eficiência parte da interface de um módulo, então
é razoável usar esses sufixos. No entanto, seria preferível, se o nosso
objectivo não fosse o estudo dos algoritmos em si, mas a criação de
ferramentas para utilização futura ou para disponibilização a terceiros, usar
sufixos que fossem reveladores da eficiência da função, e não da sua
implementação.</p>
<p>Antes, porém, de passar às implementações, é preciso dizer que o presente
oferecido ao Sr. Fibonacci está realmente envenenado. Com efeito, a sucessão
de Fibonacci cresce de forma extremamente rápida. Assim, no mês 120, ou seja,
dez anos depois da oferta do casal original, o número de casais a alimentar é
exactamente 5&thinsp;358&thinsp;359&thinsp;254&thinsp;990&thinsp;966&thinsp;640&thinsp;871&thinsp;840.
Este valor é demasiado grande para os <code>int</code> nas nossas máquinas habituais,
que têm 32 <em>bits</em>, ou mesmo para os <em>long</em>, com 64 <em>bits</em> nessas mesmas
máquinas. Por outro lado, a precisão limitada dos tipos de virgula flutuante
pode pôr problemas complicados ao cálculo dos termos da sucessão (já
tínhamos dito que dos tipos de vírgula flutuante se foge como diabo da
cruz?). O código abaixo recorre ao tipo <code>long</code>, numa tentativa de evitar que
se atinjam muito cedo os limites dos inteiros. É uma má solução, no entanto.
Uma boa solução passaria pela utilização de um tipo capaz de representar
números inteiros de dimensão arbitrária (desde que haja memória para o
guardar, bem entendido). A implementação de um tal tipo é um excelente
exercício de algoritmos e estruturas de dados, mas não o resolveremos aqui.</p>
<h2>Implementação</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Como se referiu, usamos <code>long</code> como tipo de devolução das funções de cálculo
dos termos da sucessão de Fibonacci. Será que isso adianta muito, em relação
à utilização de <em>int</em>? Fazendo algumas experiências, é fácil verificar que,
em máquinas em que os <code>int</code> têm 32 <em>bits</em>, ou seja, em máquinas em que o
maior valor representável num <code>int</code> é 2&thinsp;147&thinsp;483&thinsp;647, o
maior termo da sucessão de Fibonacci representável num <code>int</code> é o termo 46, ou
seja, <img src="http://bit.ly/XgffV7" alt="F(46)">, cujo valor é
1&thinsp;836&thinsp;311&thinsp;903. Isto é, usando <code>int</code> só conseguimos obter
valores correctos para os primeiros 47 termos da sucessão. Usando <code>long</code>, é
fácil verificar que, em máquinas em que os <code>long</code> têm 64 <em>bits</em>, ou seja, em
máquinas em que o maior valor representável num <code>long</code> é
9&thinsp;223&thinsp;372&thinsp;036&thinsp;854&thinsp;775&thinsp;807, o maior
termo da sucessão de Fibonacci representável num <code>long</code> é o termo 92, ou
seja, <img src="http://bit.ly/12kthcr" alt="F(92)">, cujo valor é
7&thinsp;540&thinsp;113&thinsp;804&thinsp;746&thinsp;346&thinsp;429. Isto é,
usando <code>long</code> só conseguimos obter valores correctos para os primeiros 93
termos da sucessão. Melhor que os 47 se se usasse <code>int</code>, mas ainda assim um
valor bem pequeno.</p>
<p>O maior termo calculável usando <code>long</code>, 92, deve ser usado nas pré-condições
das funções abaixo. Usar o valor literal nesse código é muito má ideia, pois
torna mais difícil a compreensão do código. Afinal, haverá que perceba
imediatamente o significado desse valor? Para resolver o problema definimos
uma constante para guardar esse valor. Uma vez que esta constante será usada
para dimensionar <em>arrays</em> que pretendemos inicializar usando as usuais listas
de inicializadores do C, não podemos usar a forma mais óbvia de definir
constantes em C, i.e., não podemos usar</p>
<pre><code class="lang-C">const int maximum_term_fitting_a_long = 92;</code></pre>
<p>tendo, pelo contrário de usar uma macro do pré-processador.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#define MAXIMUM_TERM_FITTING_A_LONG 92</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3>Inclusão de ficheiros de cabeçalho</h3>
<p>Incluímos os seguintes ficheiros de cabeçalho:</p>
<ul>
<li><p><code>stdio.h</code> &ndash; Para declaração do procedimento <code>printf()</code>.</p>
</li>
<li><p><code>stdlib.h</code> &ndash; Para definição da <em>macro</em> <code>EXIT_SUCCESS</code>.</p>
</li>
<li><p><code>time.h</code> &ndash; Para definição da função <code>clock()</code> e da macro
<code>CLOCKS_PER_SEC</code>.</p>
</li>
<li><p><code>assert.h</code> &ndash; Para definição da macro <code>assert()</code>.</p>
</li>
</ul>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;assert.h&gt;</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h3>Inclusão de ficheiros de cabeçalho próprios</h3>
<p>Incluímos apenas um ficheiro de cabeçalho «não oficial»:</p>
<ul>
<li><code>sequence_of_longs.h</code> &ndash; Para declaração do TAD sucessão de <code>long</code>
usada para guardar em memória dos termos da sucessão já calculados.</li>
</ul>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include "sequence_of_longs.h"</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h3>Implementação recursiva «estúpida»</h3>
<h4>Documentação</h4>
<p>A documentação da função é feita no formato do
<a href="http://doxygen.org/">Doxygen</a>, como habitualmente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fiboncci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term of the Fibonacci sequence. The time taken
 * by the function grows exponentially with `n`.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the Fibonacci sequence. It is assumed the sequence
 * starts at `n` = 0, with value 0, followed by value 1, at `n` = 1. That is,
 * the sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h4>Definição</h4>
<p>Esta implementação segue a estratégia mais comum das soluções recursivas:
decompor o problema em problemas mais simples, resolver esses problemas mais
simples usando exactamente a mesma estratégia, recursivamente, e compor as
soluções dos subproblemas de modo a obter a solução do problema como um todo.
Uma solução recursiva, como esta, precisa de possuir casos de paragem (ou
casos especiais), para os quais a solução é imediata, não sendo necessária
qualquer decomposição adicional. A definição recursiva da sucessão de
Fibonacci aparenta adequar-se bem a esta estratégia:</p>
<p><img src="http://bit.ly/169sagW" alt="F(n)={0, se n = 0, 1, se n = 1, e F(n-2) + F(n-1), se n &gt; 
1}"></p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> stupidly_recursive_fibonacci(<span class="keyword">int</span> n)
{
</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Em primeiro lugar, verificamos as pré-condições e lidamos com as
violações que forem detectadas.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Depois, lidamos com os dois casos especiais da sucessão. Estes casos
servem também para garantir que as invocações recursivas desta função
acabarão sempre por terminar (em tempo finito).</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n == <span class="number">0</span>)
		<span class="keyword">return</span> <span class="number">0L</span>;
	<span class="keyword">if</span> (n == <span class="number">1</span>)
		<span class="keyword">return</span> <span class="number">1L</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>O caso geral é simplesmente a devolução da soma dos termos anterior
da sucessão. Para os obter, invocamos a própria função com os dois
valores inteiros anteriores a <code>n</code>. O problema desta implenentação é
que se está a reduzir o problema de calcular
<img src="http://bit.ly/ZCdcqY" alt="F(n)"> aos subproblemas de calcular
<img src="http://bit.ly/14HrTAK" alt="F(n-2)"> e de calcular
<img src="http://bit.ly/13V2Vid" alt="F(n-1)">, <em>mas estes subproblemas não são
independentes!</em> Isso faz com que esta implementação seja muitíssimo
ineficiente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> stupidly_recursive_fibonacci(n - <span class="number">2</span>)
		+ stupidly_recursive_fibonacci(n - <span class="number">1</span>);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Para compreendemos bem a ineficiência desta implementação, vamos calcular
alguns valores interessantes.</p>
<p>Em primeiro lugar, uma revelação: a sucessão de Fibonacci pode ser expressa
de forma fechada. «Estamos aqui com tudo isto e a coisa resume-se a uma
fórmula fechada?», podem perguntar. Sim. Mas pode haver boas razões para não
recorrer a essa fórmula: ela obriga-nos a trabalhar com valores de vírgula
flutuante e, por isso, a lidar com as correspondentes limitações de precisão.
As nossas implementações, recorrendo a <em>long</em>, são exactas... Podem encontrar
informação sobre a sucessão de Fibonacci em vários locais. Recomendo os
seguintes:</p>
<ul>
<li><p><a href="http://www.wolframalpha.com/input/?i=F_n">F_n</a> no
<a href="http://www.wolframalpha.com/">Wolfram|Alpha</a> - O Wolfram|Alpha é um motor
de pesquisa com a <a href="http://www.wolfram.com/">Wolfram</a> por trás (a mesma que
produz o maravilhoso
<a href="http://www.wolfram.com/mathematica/">Wolfram|Mathematica</a>) só podia ser
excelente. E é-o.</p>
</li>
<li><p><a href="http://mathworld.wolfram.com/FibonacciNumber.html">Fibonacci Number</a> no
<a href="http://mathworld.wolfram.com/">Wolfram|MathWorld</a> - O Wolfram|MathWorld é
uma enciclopédia matemática também com a garantia de qualidade da
<a href="http://www.wolfram.com/">Wolfram</a>. Outra excelente fonte de informação.</p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci number</a> na
<a href="http://en.wikipedia.org/">Wikipédia</a>.</p>
</li>
</ul>
<p>A forma fechada da sucessão de Fibonacci é</p>
<p><img src="http://bit.ly/10fxJ6c" alt="F_n=(phi^n - psi^n)/sqrt(5)">,</p>
<p>onde</p>
<p><img src="http://bit.ly/15hTKsW" alt="phi=(1+sqrt(5))/2">, que é chamado <em>número de ouro</em>,
e</p>
<p><img src="http://bit.ly/12Elq43" alt="psi=(1-sqrt(5))/2">.</p>
<p>Outra forma fechada é</p>
<p><img src="http://bit.ly/1254VAx" alt="F_n=arred(phi^n/sqrt(5))">,</p>
<p>onde</p>
<p><img src="http://bit.ly/10bSbcU" alt="arred(x)"></p>
<p>é a função que resulta no inteiro mais próximo ou arredondamento de
<img src="http://bit.ly/12ElMrk" alt="x">, sendo que em caso de empate entre dois inteiros
mais próximos se escolhe o inteiro que for par.</p>
<p>Ambas as formas mostram bem o que já tínhamos observado: o crescimento da
sucessão de Fibonacci é extremamente rápido. Mais precisamente, o crescimento
da sucessão de Fibonacci é <em>exponencial</em>, sendo a base da exponencial o
número de ouro e o expoente o número do termo da sucessão.</p>
<p>Vamos agora calcular o número de invocações da função <code>recursive_fibonacci()</code>
que ocorrem durante a cálculo de um dado termo <img src="http://bit.ly/Z4ELdk" alt="n"> da
sucessão de Fibonacci, ou seja, durante a execução da função que acabámos de
definir quando se lhe passa como argumento esse valor
<img src="http://bit.ly/Z4ELdk" alt="n">. Chamemos a esse número de invocações
<img src="http://bit.ly/139Mk7p" alt="N_n">.</p>
<p>Em primeiro lugar, é evidente que invocar <code>recursive_fibonacci()</code> com
<img src="http://bit.ly/Z4ELdk" alt="n"> como argumento leva a uma invocação inicial,
nomeadamente a que acabámos de referir, com <img src="http://bit.ly/Z4ELdk" alt="n"> como
argumento. Se o valor de <img src="http://bit.ly/Z4ELdk" alt="n"> for 0 ou 1, então não é
realizada qualquer outra invocação. Ou seja, <img src="http://bit.ly/YwMaHD" alt="N_n=1">
quando <img src="http://bit.ly/10afb7o" alt="n=0"> ou <img src="http://bit.ly/14HsgeM" alt="n=1">. Se o
valor de <img src="http://bit.ly/Z4ELdk" alt="n"> for maior que 1, então a função será
invocada recursivamente com os valores <img src="http://bit.ly/18mQyLi" alt="n-2"> e
<img src="http://bit.ly/10fBCrR" alt="n-1"> como argumento, o que resultará num total de
<img src="http://bit.ly/Zxxpzv" alt="1+N_n-2+N_n-1"> invocações. Ou seja, o número de
invocações recursivas da função pode ser expresso também de forma recursiva:</p>
<p><img src="http://bit.ly/125adMb" alt="definição recursiva de N_n"></p>
<p>Esta definição é muito parecida com a definição recursiva da própria sucessão
de Fibonacci. De facto, é fácil demonstrar que <img src="http://bit.ly/10zTgWa" alt="N_n =
2F_n+1-1">. Ou seja, o número de invocações cresce
exponencialmente, tal como a própria sucessão de Fibonacci! Não admira que
esta implementação seja absolutamente inaceitável...</p>
<p>Já agora, podemos também calcular o número de somas realizadas. Seja
<img src="http://bit.ly/13g3vTT" alt="S_n"> o número de somas realizadas quando se invoca
<code>recursive_fibonacci()</code> com o argumento <img src="http://bit.ly/Z4ELdk" alt="n">. É fácil
ver que, quando <img src="http://bit.ly/Z4ELdk" alt="n"> é 0 ou 1, a invocação de
<code>recursive_fibonacci()</code> resulta em 0 somas. Quando se invoca com
<img src="http://bit.ly/Z4ELdk" alt="n"> maior que 1, realiza-se uma soma dos resultados
das invocações recursivas com os valores <img src="http://bit.ly/18mQyLi" alt="n-2"> e
<img src="http://bit.ly/10fBCrR" alt="n-1"> como argumento, o que resultará num total de
<img src="http://bit.ly/YnkQcQ" alt="1+S_n-2+S_n-1"> somas. Ou seja, o número de somas
realizadas durante a invocação da função pode ser expresso também de forma
recursiva:</p>
<p><img src="http://bit.ly/13VO8Ql" alt="definição recursiva de S_n"></p>
<p>Esta definição é também muito parecida com a definição recursiva da própria
sucessão de Fibonacci. De facto, é fácil demonstrar que <img src="http://bit.ly/139Tdpr" alt="S_n =
F_n+1-1">. Ou seja, o número de somas cresce
exponencialmente, tal como a própria sucessão de Fibonacci! Isto quando uma
implementação iterativa trivial precisa de 0 somas para calcular o termo 0 da
sucessão e de <img src="http://bit.ly/10fBCrR" alt="n-1"> somas para calcular o termo
<img src="http://bit.ly/Z4ELdk" alt="n"> quando <img src="http://bit.ly/ZteSVa" alt="n&gt;0">. Mais uma vez,
não admira que esta implementação seja absolutamente inaceitável.</p>
<p>A moral desta estória não é que a recursividade seja naturalmente perversa.
Não o é. As soluções recursivas podem ser tão eficientes quanto as soluções
iterativas. O problema aqui não é a recursividade em si, mas o algoritmo
usado.</p>

            </div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h3>Implementação recursiva com <em>lookup</em></h3>
<h4>Documentação</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fibonacci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term of the Fibonacci sequence. The time taken
 * by the function grows !!!!!!!!!!!!!!!!!!!! with `n`.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the Fibonacci sequence. It is assumed the sequence
 * starts at `n` = 0, with value 0, followed by value 1, at `n` = 1. That is,
 * the sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> recursive_fibonacci(<span class="keyword">int</span> n)
{
	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Esta implementação evita os cálculos repetidos dos mesmos termos da
sucessão de Fibonacci usando uma memória auxiliar. A ideia é calcular
cada termo da sucessão uma única vez, guardar o seu valor em memória
e, das próximas vezes que o termo for solicitado, usar o valor
guardado em memória. Isto implica, naturalmente, que a memória usada
persista para além do âmbito restrito de uma execução da função. Ou
seja, não podemos de forma nenhuma usar variáveis locais
<em>automáticas</em>, pois estas são construídas quando a instrução que as
define é executada, e destruídas quando se atinge o final do bloco
onde a sua definição se encontra. Em vez de partir daqui as variáveis
globais, cujo tempo de vida abarca todo o tempo de execução do
programa, e que são visíveis em todo o programa, preferimos usar
variáveis locais <em>estáticas</em>. Estas variáveis definem-se usando o
<em>qualificador</em> <code>static</code>, duram desde a execução da instrução que as
define até o final do programa e têm a mesma visibilidade restrita
que qualquer variável local tem. Note-se que a instrução de definição
de qualquer variável local estática é executada uma única vez,
nomeadamente a primeira vez que o fluxo de execução do programa passa
por essa instrução. A partir daí a instrução de definição, com a
respectiva inicialização, é ignorada. Logo, a inicialização de uma
variável local estática <em>é feita uma única vez</em> durante a execução do
programa.</p>
<p>Uma vez que o número de termos da sucessão de Fibonacci calculáveis
através desta função é limitado, dado que ela devolve valores <code>long</code>,
só se podendo calcular o valor dos termos entre 0 e
<code>MAXIMUM_TERM_FITTING_A_LONG</code>, podemos reservar espaço para todos os
termos num <em>array</em> <code>F</code> de <code>long</code>. A utilização de uma macro
<code>MAXIMUM_TERM_FITTING_A_LONG</code> na expressão para cálculo do
comprimento do <em>array</em> permite-nos usar inicializadores do C. Dessa
forma, podemos inicializar a memória dos termos da sucessão de
Fibonacci com os dois primeiros termos dessa sucessão, que têm os
valores 0 e 1, respectivamente, correspondentes aos termos com
índices 0 e 1.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">static</span> <span class="keyword">long</span> F[MAXIMUM_TERM_FITTING_A_LONG + <span class="number">1</span>] = {<span class="number">0</span>, <span class="number">1</span>};
</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Não basta definir o espaço de memória dos termos da sucessão: é
necessário definir uma variável que guarde em cada instante quantos
termos estão já calculados. Neste caso inicializa-se a variável com o
valor 2, uma vez que se inicializou a memória com os dois primeiros
termos da sucessão de Fibonacci.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">static</span> <span class="keyword">int</span> number_of_calculated_terms = <span class="number">2</span>;

</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Estamos agora preparados para indagar o valor do termo da sucessão de
Fibonacci solicitado. Se o termo já constar na memória de termos
calculados, i.e., se o valor <code>n</code> for inferior a
<code>number_of_calculated_terms</code> limitamo-nos a devolver o valor
memorizado.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n &lt; number_of_calculated_terms)
		<span class="keyword">return</span> F[n];

</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>O caso geral passa por</p>
<ol>
<li><p>invocar recursivamente a própria função para obter os termos <code>n -
2</code> e <code>n - 1</code>,</p>
</li>
<li><p>calcular o termo <code>n</code> como soma dos dois termos anteriores
calculados,</p>
</li>
<li><p>guardar esse novo termo na memória, de modo a não precisar de ser
recalculado, e</p>
</li>
<li><p>terminar a função, devolvendo o valor do novo termo ao retornar ao
ponto de invocação da função.</p>
</li>
</ol>
<p>Estes passos estão condensados em apenas duas linhas de código. Essa
condensação seria considerada uma má prática em quase todas as
linguagens de programação, mas este tipo de código é idiomático em C,
pelo que preferimos apresentá-lo desta forma. Seja como for, uma
forma ortodoxa de escrever este código seria:</p>
<pre><code class="lang-C">F[n] = recursive_fibonacci(n - 2) + recursive_fibonacci(n - 1);
number_of_calculated_terms++;

return F[n];</code></pre>
<p>Alternativamente, podemos considerar que o caso especial é aquele em
que o termo pretendido <em>não</em> foi ainda calculado, o que nos levaria
ao seguinte código, bem mais legível, que substitui não apenas as
duas últimas linhas do código apresentado, mas também as duas
anteriores:</p>
<pre><code class="lang-C">if (number_of_calculated_terms &lt;= n) {
        F[n] = recursive_fibonacci(n - 2) + 
               recursive_fibonacci(n - 1);
        number_of_calculated_terms++;
}

return F[n];</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>	number_of_calculated_terms++;
	<span class="keyword">return</span> F[n] = recursive_fibonacci(n - <span class="number">2</span>) + recursive_fibonacci(n - <span class="number">1</span>);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h3>Implementação recursiva com <em>lookup</em> usando TAD</h3>
<h4>Documentação</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fibonacci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term of the Fibonacci sequence. The time taken
 * by the function grows !!!!!!!!!!!!!!!!!!!! with `n`.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the Fibonacci sequence. It is assumed the sequence
 * starts at `n` = 0, with value 0, followed by value 1, at `n` = 1. That is,
 * the sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> recursive_fibonacci_using_ADT(<span class="keyword">int</span> n)
{
	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Em vez de se um <em>array</em> de <code>long</code> como memória para os termos já
calculados da sucessão de Fibonacci, bem como um inteiro indicando a
quantidade de termos memorizados, recorremos aqui ao TAD sucessão de
<code>long</code>, representado pela estrutura <code>struct sequence_of_longs</code>. No
caso particular da sequência se Fibonacci, a utilização deste TAD não
traz grandes vantagens face à utilização de um <em>array</em>, dada a
pequena quantidade de termos da sucessão representáveis no tipo
<em>long</em>. No entanto, é um bom exercício recorrer aqui ao TAD,
exercício que nos pode ser útil noutros casos em que o
dimensionamento <em>a priori</em> do <em>array</em> não seja tão fácil.</p>
<p>Tal como definido o TAD, o código cliente só pode trabalhar com as
sucessões através de ponteiros. Assim, precisamos de definir uma
variável local <em>estática</em> (de modo a que o seu valor persiste entre
invocações da função <code>recursive_fibonacci_using_ADT</code>). Dadas as
restrições do C, não podemos usar o construtor <code>SEQL_new()</code>
directamente na inicialização, que tem de ser feita usando uma
<em>expressão constante</em>. Assim, optámos por inicializar o ponteiro <code>F</code>
com o valor especial <code>NULL</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">static</span> <span class="keyword">struct</span> sequence_of_longs *F = NULL;

</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Dada a inicialização do ponteiro com <code>NULL</code>, podemos agora detectar o
seu valor inicial <code>NULL</code> para lhe atribuir o endereço de uma nova
estrutura <code>struct sequence_of_longs</code> construída de forma dinâmica
através do construtor <code>SEQL_new()</code>. Este código é executado sempre
que a função é invocada, o que é uma infelicidade, mas não há forma
de o evitar, dado que não é possível inicializar o ponteiro <code>F</code> para
a sucessão de <code>long</code> com o valor devolvido pela função <code>SEQL_new()</code>.</p>
<p>Outro problema associado às limitações do C é o da libertação de
memória. O C não fornece nenhum mecanismo para executar código no
contexto das variáveis locais estáticas no final do programa de modo
a podermos «arrumar a casa», ou seja, libertar recursos que lhes
estejam associados. Neste caso os recursos são apenas duas variáveis
dinâmicas: (a) a <code>struct sequence_of_long</code> apontada por <code>F</code> e
(embora, como clientes, não o devêssemos precisar de saber) e (b) o
<em>array</em> dinâmico usado internamente pelo TAD para guardar os termos.
Como toda a memória dinâmica associada ao programa em execução é
libertada durante a sua terminação, a nossa violação do princípio de
que quem reserva memória explicitamente a deve também libertar
explicitamente não é dramática.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (F == NULL)
		F = SEQL_new();

</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Se o termo já constar na sucessão de <code>long</code> com os termos da sucessão
de Fibonacci já calculados, limitamo-nos a devolvê-lo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">if</span> (n &lt; SEQL_length(F))
		<span class="keyword">return</span> SEQL_term(F, n);

</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Se o termo não está ainda calculado, há que fazê-lo. Uma vez que,
depois de o calcular, teremos de o adicionar à memória e devolver,
definimos uma variável <code>F_n</code> para guardar o valor calculado. Uma vez
que o valor usado para inicializar esta variável depende do valor de
<code>n</code>, usamos o operador <code>?:</code> do C para discriminar entre as três
diferentes formas de inicialização, evitando ter de recorrer a uma
definição sem inicialização seguida de duas instruções de selecção
encadeadas:</p>
<pre><code class="lang-C">long F_n;
if (n == 0)
        F_n = 0L;
else if (n == 1)
        F_n = 1L;
else
        F_n = recursive_fibonacci_using_ADT(n - 2) + 
              recursive_fibonacci_using_ADT(n - 1);</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">long</span> F_n = n == <span class="number">0</span> ? <span class="number">0L</span> : n == <span class="number">1</span> ? <span class="number">1L</span> :
		recursive_fibonacci_using_ADT(n - <span class="number">2</span>) + 
		recursive_fibonacci_using_ADT(n - <span class="number">1</span>);

</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Agora que já temos o valor de <code>F_n</code> calculado, devemos guardá-lo em
memória, na nossa sucessão de <code>long</code>, de modo a não precisar de ser
calculado de novo.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	SEQL_add(F, F_n);

</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Finalmente, devolvemos o valor calculado.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> F_n;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h3>Implementação recursiva eficiente sem memória</h3>
<h4>Função auxiliar</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> tr_fibonacci(<span class="keyword">int</span> n, <span class="keyword">int</span> previous_value, <span class="keyword">int</span> value)
{
    <span class="keyword">if</span> (n == <span class="number">1</span>)
        <span class="keyword">return</span> value;

    <span class="keyword">return</span> tr_fibonacci(n - <span class="number">1</span>, value, previous_value + value);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h4>Documentação</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fibonacci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term of the Fibonacci sequence. The time taken
 * by the function grows !!!!!!!!!!!!!!!!!!!! with `n`.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the Fibonacci sequence. It is assumed the sequence
 * starts at `n` = 0, with value 0, followed by value 1, at `n` = 1. That is,
 * the sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> tail_recursive_fibonacci(<span class="keyword">int</span> n)
{
    <span class="keyword">if</span> (n == <span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">0</span>;

    <span class="keyword">return</span> tr_fibonacci(n, <span class="number">0</span>, <span class="number">1</span>);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h3>Implementação iterativa</h3>
<h4>Documentação</h4>
<p>A documentação da função é feita no formato do
<a href="http://doxygen.org/">Doxygen</a>, como habitualmente.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief Returns the `n`th term of the Fiboncci sequence.
 *
 * \param n The number of the term to return (first valid value is 0).
 * \return The value of the `n`th term of the Fibonacci sequence. The time taken
 * by the function grows linearly with `n`.
 * \pre `n` ≥ 0
 * \post result = \f$F_{\mathtt{n}}\f$
 *
 * Returns the `n`th term of the Fibonacci sequence. It is assumed the sequence
 * starts at `n` = 0, with value 0, followed by value 1, at `n` = 1. That is,
 * the sequence is defined by
 * \f[
 * F_n = \left\{\begin{array}{ll}
 *     0                 &amp; \text{if } n=0, \\
 *     1                 &amp; \text{if } n=1\text{, and} \\
 *     F_{n-2} + F_{n-1} &amp; \text{if } n&gt;1.
 *   \end{array}\right.
 * \f]
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> iterative_fibonacci(<span class="keyword">int</span> n)
{
	assert(n &gt;= <span class="number">0</span>);
	assert(n &lt;= MAXIMUM_TERM_FITTING_A_LONG);

	<span class="keyword">if</span> (n == <span class="number">0</span>)
		<span class="keyword">return</span> <span class="number">0L</span>;
	<span class="keyword">if</span> (n == <span class="number">1</span>)
		<span class="keyword">return</span> <span class="number">1L</span>;

	<span class="keyword">long</span> previous_term = <span class="number">1L</span>;
	<span class="keyword">long</span> current_term = <span class="number">1L</span>;
	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i != n; i++) {
		current_term += previous_term;
		previous_term = current_term - previous_term;
	}

	<span class="keyword">return</span> current_term;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h3>Procedimento !!!!!!!</h3>
<h4>Documentação</h4>
<p>!!!!!!!!</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="comment">/** \brief !!!!!!!!!!!! (includes month 0)
 *
 * \param n !!!!!!!!!
 * \return !!!!!!!!!!!
 * \pre `n` ≥ 0
 * \post !!!
 *
 * !!!!!!!!!!!!!!!
 */</span>
</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <h4>Definição</h4>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">void</span> experiment_efficiency_of(<span class="keyword">char</span> title[], <span class="keyword">long</span> fibonacci(<span class="keyword">int</span>),
			<span class="keyword">int</span> last_term)
{
	printf(<span class="string">"%s\n"</span>, title);
	<span class="keyword">double</span> previous_time = <span class="number">0.0</span>;
	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n != last_term + <span class="number">1</span>; n++) {
		clock_t start = clock();
		<span class="keyword">int</span> f = fibonacci(n);
		clock_t end = clock();
		<span class="keyword">double</span> time = (<span class="keyword">double</span>) (end - start) / CLOCKS_PER_SEC;
		printf(<span class="string">"f(%d) = %d in %.4fs %g\n"</span>, n, f, time,
			time / previous_time);
		previous_time = time;
	}
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <h3>Procedimento !!!!!!!</h3>
<p>!!!!!!!!</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> main(<span class="keyword">void</span>)
{
	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n != MAXIMUM_TERM_FITTING_A_LONG + <span class="number">1</span>; n++) {
</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <pre><code>printf(&quot;F(%d) [stupid recursive] = %ld\n&quot;, n, stupidly_recursive_fibonacci(n));</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>		printf(<span class="string">"F(%d) [recursive         ] = %ld\n"</span>, n, recursive_fibonacci(n));
		printf(<span class="string">"F(%d) [recursive with ADT] = %ld\n"</span>, n, recursive_fibonacci_using_ADT(n));
		printf(<span class="string">"F(%d) [iterative         ] = %ld\n"</span>, n, iterative_fibonacci(n));
		putchar(<span class="string">'\n'</span>);
	}

	experiment_efficiency_of(<span class="string">"Stupidly recursive implementation of the fibonacci sequence:"</span>,
				stupidly_recursive_fibonacci, <span class="number">35</span>);
	experiment_efficiency_of(<span class="string">"Recursive implementation of the fibonacci sequence:"</span>,
				recursive_fibonacci, <span class="number">35</span>);
	experiment_efficiency_of(<span class="string">"Recursive implementation of the fibonacci sequence using ADT for storage:"</span>,
				recursive_fibonacci_using_ADT, <span class="number">35</span>);
	experiment_efficiency_of(<span class="string">"Three variable iterative implementation of the fibonacci sequence:"</span>,
				iterative_fibonacci, <span class="number">35</span>);

	<span class="keyword">return</span> EXIT_SUCCESS;
}

</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
