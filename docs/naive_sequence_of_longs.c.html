<!DOCTYPE html>

<html>
<head>
  <title>`sequence_of_longs.c` &ndash; Implementação das sucessões de `long`</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script src="http://softwaremaniacs.org/media/soft/highlight/highlight.pack.js"></script>
  <script>
    hljs.tabReplace = '        ';
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="array_of_routines.c.html">
                array_of_routines.c
              </a>
            
              
              <a class="source" href="array_utils.h.html">
                array_utils.h
              </a>
            
              
              <a class="source" href="print.c.html">
                print.c
              </a>
            
              
              <a class="source" href="arrays_and_pointers.c.html">
                arrays_and_pointers.c
              </a>
            
              
              <a class="source" href="arrays_basics.c.html">
                arrays_basics.c
              </a>
            
              
              <a class="source" href="command_line.c.html">
                command_line.c
              </a>
            
              
              <a class="source" href="fibonacci.c.html">
                fibonacci.c
              </a>
            
              
              <a class="source" href="hello_world.c.html">
                hello_world.c
              </a>
            
              
              <a class="source" href="hello_world_correct.c.html">
                hello_world_correct.c
              </a>
            
              
              <a class="source" href="linked_list.c.html">
                linked_list.c
              </a>
            
              
              <a class="source" href="malloc_stuff.c.html">
                malloc_stuff.c
              </a>
            
              
              <a class="source" href="nans_and_other_oddities.c.html">
                nans_and_other_oddities.c
              </a>
            
              
              <a class="source" href="rationals_with_structs.c.html">
                rationals_with_structs.c
              </a>
            
              
              <a class="source" href="routine_pointers.c.html">
                routine_pointers.c
              </a>
            
              
              <a class="source" href="experiments.c.html">
                experiments.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.c.html">
                naive_sequence_of_longs.c
              </a>
            
              
              <a class="source" href="naive_sequence_of_longs.h.html">
                naive_sequence_of_longs.h
              </a>
            
              
              <a class="source" href="sequence_of_longs.c.html">
                sequence_of_longs.c
              </a>
            
              
              <a class="source" href="sequence_of_longs.h.html">
                sequence_of_longs.h
              </a>
            
              
              <a class="source" href="tests.c.html">
                tests.c
              </a>
            
              
              <a class="source" href="sizeof_and_arrays.c.html">
                sizeof_and_arrays.c
              </a>
            
              
              <a class="source" href="array_of_doubles.c.html">
                array_of_doubles.c
              </a>
            
              
              <a class="source" href="array_of_doubles.h.html">
                array_of_doubles.h
              </a>
            
              
              <a class="source" href="perform_experiments.c.html">
                perform_experiments.c
              </a>
            
              
              <a class="source" href="sorting_algorithms.c.html">
                sorting_algorithms.c
              </a>
            
              
              <a class="source" href="sorting_algorithms.h.html">
                sorting_algorithms.h
              </a>
            
              
              <a class="source" href="string_io.c.html">
                string_io.c
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1><code>sequence_of_longs.c</code> &ndash; Implementação das sucessões de <code>long</code></h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2>Implementação do módulo físico <code>sequence_of_longs</code></h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Para uma explicação mais pormenorizada das várias partes deste ficheiro, e da
implementação das várias rotinas,  consultar a explicação do correspondente
ficheiro <a href="sequence_of_longs.c.html"><code>sequence_of_longs.c</code></a>. Neste ficheiro
explica-se apenas aquilo que é específico desta implementação ingénua do TAD
sucessão de <code>long</code>.</p>
<p>Este ficheiro de implementação contém a implementação do módulo físico
<code>naive_sequence_of_longs</code>. A interface deste módulo encontra-se no ficheiro de
cabeçalho ou de interface <a href="naive_sequence_of_longs.h.html"><code>naive_sequence_of_longs.h</code></a>.</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h3>Inclusão do cabeçalho correspondente a esta implementação</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include "naive_sequence_of_longs.h"</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h3>Inclusão de ficheiros de cabeçalho necessários no código de implementação</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3>Definição da estrutura <code>struct naive_sequence_of_long</code></h3>
<p>Esta estrutura contém dois campos ou atributos:</p>
<ul>
<li><p><code>terms</code> &ndash; Um ponteiro para o <em>array</em> dinâmico que contém os termos da
sucessão.</p>
</li>
<li><p><code>length</code> &ndash; Inteiro guardando o comprimento actual da sucessão, i.e.,
o seu número de termos. Note que o comprimento da sucessão é sempre
igual ao comprimento do <code>array</code> que guarda os termos.</p>
</li>
</ul>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">struct</span> naive_sequence_of_longs {
	<span class="keyword">long</span> *terms;
	<span class="keyword">int</span> length;
};

</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h3>Implementação dos procedimentos que imprimem as sucessões</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">void</span> NSEQL_print(<span class="keyword">struct</span> naive_sequence_of_longs *sl)
{
	putchar(<span class="string">'{'</span>);
	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sl-&gt;length; i++) {
		<span class="keyword">if</span> (i != <span class="number">0</span>)
			printf(<span class="string">", "</span>);
		printf(<span class="string">"%ld"</span>, sl-&gt;terms[i]);
	}
	putchar(<span class="string">'}'</span>);
}

<span class="keyword">void</span> NSEQL_println(<span class="keyword">struct</span> naive_sequence_of_longs *sl)
{
	NSEQL_print(sl);
	putchar(<span class="string">'\n'</span>);
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h3>Implementação do construtor do TAD</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">struct</span> naive_sequence_of_longs *NSEQL_new(<span class="keyword">void</span>)
{
</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Reservamos primeiro espaço para uma nova <code>struct sequence_of_longs</code>
usando a rotina <code>malloc()</code>. Obtemos a quantidade de unidades de
memória a reservar usando o operador <code>sizeof</code>. Guardamos o endereço
dessa nova variável dinâmica no ponteiro <code>sl</code>, através do qual se
passará a manipular a nova sucessão de <code>long</code>. No final do construtor
este ponteiro será devolvido.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">struct</span> naive_sequence_of_longs *sl =
		malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> naive_sequence_of_longs));

</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>De seguida inicializamos os campos ou atributos da rotina com valores
apropriados para uma sucessão vazia. O comprimento de uma sucessão
vazia é naturalmente 0. Uma vez que não é possível ter um ponteiro
válido para um <em>array</em> dinâmico com 0 itens, inicializa-se o ponteiro
para o primeiro item desse <em>array</em> com o valor <code>NULL</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	sl-&gt;length = <span class="number">0</span>;
	sl-&gt;terms = NULL;

</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Terminada a construção da nova sucessão, há que devolver o seu
endereço (ou ponteiro), guardado na variável <code>sl</code>.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	<span class="keyword">return</span> sl;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h3>Implementação do <em>inspector</em> do comprimento</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">int</span> NSEQL_length(<span class="keyword">struct</span> naive_sequence_of_longs *sl)
{
	<span class="keyword">return</span> sl-&gt;length;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h3>Implementação do <em>modificador</em> de adição de um novo termo à sucessão</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">void</span> NSEQL_add(<span class="keyword">struct</span> naive_sequence_of_longs *sl, <span class="keyword">long</span> new_term)
{
</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Uma vez que o <em>array</em> dinâmico tem sempre a sua capacidade esgotada, adicionar um novo termo à sucessão implica sempre redimensionar esse <em>array</em>. Para aumentar a capacidade, usamos a rotina <code>realloc()</code> para reservar um
novo <em>array</em> dinâmico com capacidade para mais um termo <em>e incluindo
todos os termos que já constam na sucessão</em>. É este último
requisito que nos leva a usar a rotina <code>realloc()</code>, e não a
rotina <code>malloc()</code>. A rotina <code>realloc()</code>, se precisar de
reservar nova memória, i.e., se não conseguir simplesmente
estender o <em>array</em> existente, copiará automaticamente os
termos da memória original. É por isso que o primeiro
argumento passado a <code>realloc()</code> é um ponteiro para o <em>array</em>
original.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>	sl-&gt;terms = realloc(sl-&gt;terms, (sl-&gt;length + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));

</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Finalmente, guardamos o novo termo <code>new_term</code> no local apropriado do
<em>array</em>, que neste ponto já tem certamente (hmmmm... será?)
capacidade suficiente, i.e., na posição <code>sl-&gt;length</code>. Depois,
incrementamos o comprimento da sucessão.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre> 	sl-&gt;terms[sl-&gt;length++] = new_term;
}

</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h3>Implementação do <em>inspector</em> de termo</h3>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="keyword">long</span> NSEQL_term(<span class="keyword">struct</span> naive_sequence_of_longs *sl, <span class="keyword">int</span> index)
{
	<span class="keyword">return</span> sl-&gt;terms[index];
}



</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
